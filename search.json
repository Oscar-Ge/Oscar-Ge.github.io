[{"title":"p1-search","date":"2024-07-30T13:43:11.000Z","url":"/2024/07/30/CS188/p1-search/","categories":[["undefined",""]],"content":"search problemsstate spaces&amp;search problemsstate spaces: The set of all possible states that are possible in your given worldtransition model: output the next state when the specific action is taken at current statecost: Incurred when moving from one state to another after applying an actionstart state -&gt; goal test state space graphsA state space graph is constructed with states repre senting nodes, with directed edges existing from a state to its children.These edges represent actions , and any associated weights represent the cost of performing the corresponding action. uniformed searchThe standard protocol for finding a plan to get from the start state to a goal state is to maintain an outer frontier of partial plans derived from the search tree. We continually expand our frontier by removing a node (which is selected using our given strategy) corresponding to a partial plan from the frontier, and replacing it on the frontier with all its children. some rudimentary properties of the strategy: completness: is the strategy guaranteed to find it given infinite computational resources optimality: guaranteed to find the lowest cost path to a goal state? branching factor: The increase in the number of nodes on the frontier each time a frontier node is dequeued and replaced with its children is O(b) DFSalways selects the deepest frontier node from the start node for expansion.It is incomplete(might into circles!!!) Removing the deepest node and replacing it on the frontier with its children necessarily means the children are now the new deepest nodes- their depth is one greater than the depth of the previous deepest node. This implies that to implement DFS, we require a structure that always gives the most recently added objects highest priority. A last-in, first-out (LIFO) stack does exactly this, and is what is traditionally used to represent the frontier when implementing DFS![[Pasted image 20240730225547.png]] BFSalways selects the shallowest fron tier node from the start node for expansion If we want to visit shallower nodes before deeper nodes, we must visit nodes in their order of insertion. Hence, we desire a structure that outputs the oldest enqueued object to represent our frontier. For this, BFS uses a first-in, first-out (FIFO) queue, which does exactly this![[Pasted image 20240730225607.png]] UCSa strategy for exploration that always selects the lowest cost frontier node from the start node for expansion To represent the frontier for UCS, the choice is usually a heap-based priority queue, where the priority for a given enqueued node v is the path cost from the start node to v, or the backward cost of v. Intuitively, a priority queue constructed in this manner simply reshuffles itself to maintain the desired ordering by path cost as we remove the current minimum cost path and replace it with its children![[Pasted image 20240730225730.png]] informed searchIf we have some notion of the direction in which we should focus our search, we can significantly improve performance and “hone in” on a goal much more quickly. This is exactly the focus of informed search. Heuristicsdriving force that allow estimation of distance to goal states greedy searcha strategy for exploration that always selects the frontier node with the lowest heuristic value for expansion, which corresponds to the state it believes is nearest to a goal operates identically to UCS, with a priority queue Frontier Representation. The difference is that instead of using computed backward cost (the sum of edge weights in the path to the state) to assign priority, greedy search uses estimated forward cost in the form of heuristic values A* searcha strategy for exploration that always selects the frontier node with the lowest estimated total cost for expansion, where total cost is the entire cost from the start node to the goal node uses a priority queue to represent its frontier. A* combines the total backward cost (sum of edge weights in the path to the state) used by UCS with the estimated forward cost (heuristic value) used by greedy search by adding these two values, effectively yielding an estimated total cost from start to goal. global searchin some problems, we only care about finding the goal state — reconstructing the path can be trivial. For example, in Sudoku, the optimal configuration is the goal. Once you know it, you know to get there by filling in the squares one by one. Hill-Climbing SearchThe hill-climbing search algorithm (or steepest-ascent) moves from the current state towards the neighbor ing state that increases the objective value the most.![[Pasted image 20240731165514.png]]Hill-climbing is incomplete. Random restart hill-climbing on the other hand, which conducts a number of hill-climbing searches from randomly chosen initial states, is trivially complete as at some point a randomly chosen initial state can converge to the global maximum. simulated annealing searchSimulated annealing aims to combinerandomwalk(randomlymovestonearbystates)andhill-climbing to obtain a complete and efficient search algorithm. In simulated annealing we allow moves to states that can decrease the objective. The algorithm chooses a random move at each timestep. If the move leads to higher objective value, it is always accepted. If it leads to a smaller objective value, then the move is accepted with some probability. This probability is determined by the temperature parameter, which initially is high (more “bad” moves allowed) and gets decreased according to some “schedule”.![[Pasted image 20240731170524.png]] local beam searchlocal beam search keeps track of k states (threads) at each iteration. The algorithm starts with a random initialization of k states and at each iteration it takes on k new states as done in hill-climbing. These aren’t just k copies of the regular hill-climbing algorithm. Crucially, the algorithm selects the k best successor states from the complete list of successor states from all the threads. If any of the threads finds the optimal value the algorithm stops. Genetic AlgorithmsGenetic algorithms begin as beam search with k randomly initialized states called the population. States (called individuals ) are represented as a string over a finite alphabet. Each individual is evaluated using an evaluation function (fitness function) and they are ranked according to the values of that function. For the 8-Queens problem this is the number of non-attacking (non-conflicted) pairs of queens. ![[Pasted image 20240803193425.png]]pseudocode:![[Pasted image 20240803194215.png]]"},{"title":"CSAPP-Chap8-Exceptional Control Flow","date":"2024-07-09T03:19:12.000Z","url":"/2024/07/09/CSAPP/CSAPP-Chap8/","tags":[["CSAPP","/tags/CSAPP/"],["System","/tags/System/"]],"categories":[["CSAPP","/categories/CSAPP/"]],"content":"OS There are three components in computer hardware systems Processor, main memory and I&#x2F;O devicesOS: is a program that manages the computer hardware also provides a basis for application programs and acts as an intermediary between a user of a computer and the computer hardware 2 primary purposes: Protect hardware from misuse by applications Provide applications with simple and uniform mechanisms for manipulating hardware devices![[Pasted image 20240710111247.png]] "},{"title":"CSAPP-Chap3 程序的机器级表示","date":"2024-06-27T15:17:49.000Z","url":"/2024/06/27/CSAPP/CSAPP-Chap3/","tags":[["C","/tags/C/"],["CSAPP","/tags/CSAPP/"],["X86-64","/tags/X86-64/"]],"categories":[["CSAPP","/categories/CSAPP/"]],"content":"主要学习内容：x86汇编 程序编码编译代码：linux&gt; gcc -Og -o p p1.c p2.c-Og 指使用机器代码实际编译流程：首先， 预处理器扩展源代码，插入所有用巨nelude 命令指定的文件，并扩展所有用 #define 声明指定的宏。其次，编译器产生两个源文件的汇编代码，名字分别为 pl. p2.s 。接下来，汇器会将汇编代码转化成二进制目标代码文件 pl.a p2.o 目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。最后，链接器将两个目标代码文件与实现库函数（例如 printf) 的代码合并，并产生最终的可执行代码文件（由命令行指示符 -op 指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式 机器级代码x86-64 的机器代码和原始的 代码差别非常大。一些通常对 语言程序员隐藏的处理器状态都是可见的： 程序计数器（通常称为 “PC”, x86-64 中用％豆 表示）给出将要执行的下一条指令在内存中的地址。 整数寄存器(register)文件包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址（对应于 语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。 条件码寄存器(codition codes)保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现 if while 语句。 一组向量寄存器可以存放一个或多个整数或浮点数值。 e.g. 使用linux&gt; gcc -Og -S mstore.c会产生汇编文件mstore.s，包括以下几行： 我们可以用objdump充当反汇编器汇编代码：linux&gt; objdump -d mstore.o生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个 main 函数。假设在文件 main.c 中有下面这样的函数： 然后，我们用如下方法生成可执行文件 prog:linux&gt; gcc -Og -o prog main.c mstore.c再进行反编译：linux&gt; objdump -d prog 格式注解所有.开头的行都是指导汇编器和器和链接器工作的伪指令，暂时可以忽略。我们的表述是 ATT格式的汇编代码，这是 GCC OBJDUMP 和其他一些我们使用的工具的默认格式。在其他intel 和微软的文档中可能有intel格式的代码。 数据格式Intel 用术语”字 (word)” 表示 16 位数据类型。因此，称 32 位数为“双字 (double words)”, 64 位数为“四字 (quad words)”。下图是所有对应的汇编代码数字类型。![[Pasted image 20240630141628.png]]大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种： movb( 传送字节）、 movw( 传送字）、 movl( 传送双字）和 movq( 传送四字） 访问信息一个 x86-64 的中央处理单元 (CPU) 包含一组 16 个存储 64 位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。![[Pasted image 20240630142700.png]]在常见的程序里不同的寄存器扮演不同的角色。其中最特别的是栈指针 %rsp, 用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。 操作数（operand）指示符 立即数 （immediate）表示常数值 寄存器（register） 表示寄存器内容的变量 内存引用M_b[Addr] 对存储在内存中从地址Addr开始的b个字节数的引用有多种寻址方式表示对不同形式的内存引用。Imm(rb, ri, s) 表示的是最常用的形式 这样的引用有四个组成部分：一个立即数偏移Imm, 一个基址寄存器 rb’ 个变址寄存器 r, 和一个比例因子 s, s这里 必须是1,2,4或者8。![[Pasted image 20240630143715.png]] 数据传输命令MOV最简单形式的数据传送指令-MOV 类。这些指令把数据从源位置复制到目的位置，不做任何变化。 MOV 类由四条指令组成： movb movw movl，movq，操作数据大小分别为1,2,4,8字节。对于 movq 指令来说，需要源操作数和目标操作数，源操作数可以是立即数、寄存器值或内存值的任意一种，但目标操作数只能是寄存器值或内存值。指令的具体格式可以这样写 movq [Imm|Reg|Mem], [Reg|Mem]，第一个是源操作数，第二个是目标操作数，例如： movq Imm, Reg -&gt; mov $0x5, %rax -&gt; temp = 0x5; movq Imm, Mem -&gt; mov $0x5, (%rax) -&gt; *p = 0x5; movq Reg, Reg -&gt; mov %rax, %rdx -&gt; temp2 = temp1; movq Reg, Mem -&gt; mov %rax, (%rdx) -&gt; *p = temp; movq Mem, Reg -&gt; mov (%rax), %rdx -&gt; temp = *p;这里有一种情况是不存在的，没有 movq Mem, Mem 这个方式，也就是说，我们没有办法用一条指令完成内存间的数据交换。括号的意思就是寻址，这也分两种情况： 普通模式，(R)，相当于 Mem[Reg[R]]，也就是说寄存器 R 指定内存地址，类似于 C 语言中的指针，语法为：movq (%rcx), %rax 也就是说以 %rcx 寄存器中存储的地址去内存里找对应的数据，存到寄存器 %rax 中 移位模式，D(R)，相当于 Mem[Reg[R]+D]，寄存器 R 给出起始的内存地址，然后 D 是偏移量，语法为：movq 8(%rbp),%rdx 也就是说以 %rbp 寄存器中存储的地址再加上 8 个偏移量去内存里找对应的数据，存到寄存器 %rdx 中对于寻址来说，比较通用的格式是 D(Rb, Ri, S) -&gt; Mem[Reg[Rb]+S*Reg[Ri]+D]，其中： D - 常数偏移量 Rb - 基寄存器 Ri - 索引寄存器，不能是 %rsp S - 系数除此之外，还有如下三种特殊情况 (Rb, Ri) -&gt; Mem[Reg[Rb]+Reg[Ri]] D(Rb, Ri) -&gt; Mem[Reg[Rb]+Reg[Ri]+D] (Rb, Ri, S) -&gt; Mem[Reg[Rb]+S*Reg[Ri]] MOVZ, MOVS还有两类数据移动指令，在将较小的源值复制到较大的目的时使用。所有这些指令都把数据从源（在寄存器或内存中）复制到目的寄存器 MOVZ 类中的指令把目的中剩余的字节填充为 o, MOVS 类中的指令通过符号扩展来填充，把源操作的最高位进行复制。![[Pasted image 20240630151512.png]] 压入与弹出栈数据栈是一种数据结构，可以添加或者删除值，不过要遵循”后进先出＂的原则。通过 push 操作把数据压入栈中，通过 pop 操作删除数据；![[Pasted image 20240630201837.png]]将一个四字值压入栈中，首先要将栈指针减 8, 然后将值写到新的栈顶地址。所以，pushq %rbp就等价于两条指令 算数和逻辑操作大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种（只有 leaq 没有其他大小的变种）。例如，指令类ADD 由四条加法指令组成： addb addw addl addq, 分别是字节加法、字加法、双字加法和四字加法。事实上，给出的每个指令类都有对这四种不同大小数据的指令。![[Pasted image 20240630202200.png]] LEAQleaq是movq的变形：从内存读数据到寄存器，它还可以简洁地描述普通的算术操作。例如，如果寄存%rdx 的值为 x, 那么指令 leaq 7 (%rdx, %rdx , 4), %rax 将设置寄存器 %rax 的值为 5x+7。 一元和二元操作第二组中的操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置(类似C中的++，–计算符)第三组是二元操作，其中，第二个操作数既是源又是目的。这种语法让人想起C语言中的赋值运算符，例如 x-&#x3D;y 。不过，要注意，源操作数是第一个，目的操作数是第二个。 移位操作先给出移位量，然后第二项给出的是要移位的数。 discussion我们看到图 3-10 所示的大多数指令，既可以用千无符号运算，也可以用千补码运算。只有右移操作要求区分有符号和无符号数。这个特性使得补码运算成为实现有符号整数运算的一种比较好的方法的原因之一. 特殊算数操作x86-64指令集对 128 （16字节） 数的操作提供有限的支持。![[Pasted image 20240630204649.png]]此外， x86-64 指令集还提供 两条不同的“单操作数”乘法指令，以计算两个 64值的全 128 位乘积一个是无符号数乘法 (mulq), 而另一个是补码乘法 (imulq) 。这两条指令都要求一个参数必须在寄存器 rax 中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器 %rdx( 64 位）和 rax( 64 位）中。虽然 imulq 这个名字可以用于两个不同的乘法操作，但是汇编器能够通过计算操作数的数目，分辨出想用哪条指令。 控制C语言中的某些结构，比如条件语句、循环语句和分支语句，要求有条件的执行，根据数据测试的结果来决定操作执行的顺序。 条件码除了整数寄存器， CPU 还维护着一组单个位的条件码 (condition code) 寄存器，它们描述了最近的算术或逻辑操作的属性。先来回顾一下 x86-64 处理器中不同的寄存器：![[Pasted image 20240630210958.png]]寄存器中存储着当前正在执行的程序的相关信息： 临时数据存放在 (%rax, …) 运行时栈的地址存储在 (%rsp) 中 目前的代码控制点存储在 (%rip, …) 中 目前测试的状态放在 CF, ZF, SF, OF 中 条件代码与跳转最后的四个标识位（CF, ZF, SF, OF）就是用来辅助程序的流程控制的，意思是： CF: Carry Flag (针对无符号数) 进位标志 ZF: Zero Flag 零标志 SF: Sign Flag (针对有符号数) 符号标志，最近操作得到负数 OF: Overflow Flag (针对有符号数)溢出标志：补码溢出 访问条件码常用的使用方法有三种： 1) 可以根据条件码的某种组合，将一个字节设置为 或者 1, 2) 可以条件跳转到程序的某个其他的部分， 3) 可以有条件地传送数据。SET 指令；它们之间的区别就在于它们考虑的条件码的组合是什么，这些指令名字的不同后缀指明了它们所考虑的条件码的组合。这些指令的后缀表示不同的条件而不是操作数大小。![[Pasted image 20240701094436.png]] 跳转指令跳转 (jump) 指令会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号(label) 指明。![[Pasted image 20240701110933.png]] 用条件控制来实现条件分支类似C语言goto代码控制流： 用条件传送来实现条件分支处理器中更加高效使用数据的条件转移。这种方法计算1个条件操作的两种结果，然后再根据条件是否满足从中选取一个。原始C代码和基于条件传送的实现： 汇编代码实现： 原因：处理器通过使用流水线 (pipelining) 来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存取指令、确定指令类型、从内存读数据、执行算术运算、向 内存写数据，以及更新程序计数器） 这种方法通过重叠连续指令的步骤来获得高性能，例如，在取一条指令的同时，执行它前面一条指令的算术运算。为了提高效率，采用分支预测的逻辑。错误的预测会带来严重的性能下降。![[Pasted image 20240701112437.png]]更加详细的理解：考虑以下表达式：v = test-expr ? then-expr : else-expr; 循环用条件测试和跳转组合起来实现循环的效果 do-while 循环 while循环 如果优化等级更高：首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为 do-while 循环。 for和while类似 switch使用跳转表 伪C代码如下，数组 jt 包含7个表项，每个都是 个代码块的地址。这些位置由代码的标号定义，在 jt 的表项中由代码指针指明，由标号加上&amp;&amp;前缀组成。（回想运算符＆创建一个指向数据值的指针。在做这 扩展时， GCC 的作者 们创 造了一个新的运算符&amp;＆，这个运算 符创 个指向代码位置 的指 针。 可能会类似如下汇编代码，这里 %rdi 是参数 x，%rsi 是参数 y，%rdx 是参数 z, %rax 是返回值: 通过上面的例子，我们可以大概了解处理 switch 语句的方式：大的 switch 语句会用跳转表，具体跳转时可能会用到决策树（if-elseif-elseif-else） 过程一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。 运行时栈在 x86-64 中，所谓的栈，实际上一块内存区域，这个区域的数据进出满足先进后出的原则。越新入栈的数据，地址越低，所以栈顶的地址是最小的。![[Pasted image 20240702152615.png]]可以用 pushq popq 指令将数据存入栈中或是从栈中取出。将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间。类似地，可以通过增加栈指针来释放空间。 转移控制函数 转移到函数 要简单地把程序计数器 (P 设置为 的代码的起始位。不过， 稍后从 返回的时候，处理器必须记录好它 要继续 的执行的代码位置。x86 -64 机器中，这个信息是用指 all 调用过程 来记录的。该指 会把地址 压入栈中，并将 PC 设置为 的起始地址， 压入的地址 被称为返回地址，是紧跟在 call 指令后面的那条指令的地址。对应的指令 ret 从栈中弹出地址 A, 并把 PC 设置为A。![[Pasted image 20240702185426.png]]example： 执行过程：![[Pasted image 20240702185728.png]] 数据传送x86-64 中，大部分过程间的数据传送是通过寄存器实现的 例如，我们已经看到无数的函数示例，参数在寄存器 rdi rsi 和其他寄存器中传递 。x86-64 中，可以通过寄存楛最多传递 个整型（例如整数和指针）参数 。寄 存器的使用是有特殊顺序的，寄存器使用的名字取决千要传递的数据类型的大小。![[Pasted image 20240702185917.png]]超出6个的部分就要通过栈来传递 。![[Pasted image 20240702190257.png]] 栈上的局部存储到目前为止我们看到的大多数过程示例都不需要 超出寄存器大小的本地存储区域。不过有些时候，局部数据必须存放在内存中，常见的情况包括： 寄存器不足够存放所有的本地数据。 对一个局部变蜇使用地址运算符＇＆＇，因此必须能够为它产生一个地址 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到 。在 描述数组和结构分配时，我们会讨论这个问题。运行时栈提供了一种简单的、在需要时分配、函数完成时释放局部存储的机制。既然是利用栈来进行函数调用，自然而然就可以推广到递归的情况，而对于每个过程调用来说，都会在栈中分配一个帧 Frames。每一帧里需要包含： 返回信息 本地存储（如果需要） 临时空间（如果需要）整一帧会在过程调用的时候进行空间分配，然后在返回时进行回收，在 x86-64&#x2F;Linux 中，栈帧的结构是固定的，当前的要执行的栈中包括： Argument Build: 需要使用的参数 如果不能保存在寄存器中，会把一些本地变量放在这里 已保存的寄存器上下文 老的栈帧的指针（可选）而调用者的栈帧则包括： 返回地址（因为 call 指令被压入栈的） 调用所需的参数具体如下图所示：![[Pasted image 20240702221145.png]] 递归过程递归就是一个栈的实现过程！例子 对应的汇编代码为： 实际执行的过程中，会不停进行压栈，直到最后返回，所以递归本身就是一个隐式的栈实现，但是系统一般对于栈的深度有限制（每次一都需要保存当前栈帧的各种数据），所以一般来说会把递归转换成显式栈来进行处理以防溢出。 数据分配与访问回顾一下数据类型所占字节的大小![[Pasted image 20240702221633.png]]对于数组声明T A[N];会产生两个效果： 内存中会分配一个L * N字节的连续区域，L为数据类型T的大小 引入标识符A，A可用于作为指向数组第一个元素的指针对于数组访问A[i]，若A的地址存放于%rdx，i存放于%rcx则指令movl (%rdx, %rcx, 4), %eax能访问int类型数组第i个元素。 指针运算C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩. 比如p+i就会自动成为x_p + L * i,L是p的数据类型。单操作数操作符’&amp;’和&#39;*&#39;可以产生指针和间接引用指针.例子如下图：![[Pasted image 20240705170059.png]]返回数组值的操作类型为 int, 因此涉及 字节操作（例如movl) 和寄存器（例如 %eax) 。那些返回指针的操作类型为 int * , 因此涉及 字节操作（例如 leaq) 和寄存器（例如 %rax) 。 嵌套数组对于多维的数组，基本形式是 T A[R][C]，R 是行，C 是列，如果类型 T 占 K 个字节的话，那么数组所需要的内存是 R*C*K 字节。具体在内存里的排列方式如下：![[Pasted image 20240705172143.png]]数组元素在内存中按照行优先的顺序排列。 定长数组，变长数组看不太懂一般的C语言数组都是定长数组（最好先define一个长度减少复用debug耗时），C99允许方括号内有表达式应该的意思是GCC 能够识别出程序访问多维数组的元素的步长，然后通过指针或者数组步长的加法避免更多时钟周期的乘法的优化。 异质的数据结构结构体 struct结构体是 C 语言中非常常用的一种机制，具体在内存中是如何存放的呢？ex1: ![[Pasted image 20240705173101.png]]ex2: （非对齐） ![[Pasted image 20240705173147.png]]文中讲“具体对齐的原则是，如果数据类型需要 K 个字节，那么地址都必须是 K 的倍数”——这只是windows的原则，Linux中的对齐策略是“2字节数据类型的地址必须为2的倍数，较大的数据类型（int,double,float）的地址必须是4的倍数”原因：内存访问是以4.8字节为单位，非对齐效率低下对于一个结构体来说，所占据的内存空间必须是最大的类型所需字节的倍数，所以可能需要占据更多的空间，所以在创建结构体的时候先把打的数据类型放在前面可能是一种优化 union 联合所有成员共享同一块内存空间。即使它们是不同类型，union的大小也是其最大成员的大小。在任何时候只能存储一个成员的值。如果存储了新的值，旧的值将被覆盖。Therefore, 对于类型 union U3 *的指针 p, p-&gt; p-&gt; i[O] p-&gt;v引用 的都是数据结构的起始位置. 数据对齐许多计算机系统对基本数据类型的合法地址做出了 些限制，要求某种类型对象的地址必须是某个值 K( 通常是1,2,4，8) 的倍数。 在机器级程序中将控制与数据结合起来指针as said in [[61C-P1-C]] GDB![[Pasted image 20240705204515.png]]![[Pasted image 20240705204534.png]] 内存越界引用和缓冲区溢出C对于数组引用不进行任何边界检查，局部变量和状态信息都存储在栈中–对越界的数组元素的写操作会破坏存储在栈中的状态信息！一种特别常见的状态破坏称为缓冲区溢出 (buffer overflow) 通常，在栈中分配某个字符数组来保存字符串，但是字符串的长度超出了为数组分配的空间最好使用fgets函数，限制待读入的最大字节数缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。输入一个程序字符串，包含一些可执行代码的字节编码，称为攻击代码： 对抗缓存区溢出攻击 栈随机化（stack randomization）：使得栈的位置在程序每次运行时都有变化。Linux 系统中，栈随机化已经变成了标准行为 它是更大的一类技术中的一种，这类技术称为地址空间布局随机化 (Addr ess-Space Layout Randomization), 或者简称 ASLR。每次运行时程序的不同部分 ，包括程 序代码、库代码、栈、 全局变量和堆数据，都会被加载到内存的不同区域。但是攻击者仍然可以反复地用不同的地址进行攻击，在实际攻击代码之前加一段很长的nop指令。猜中一个地址就会到达攻击代码（空操作雪橇） 栈破坏检测（stack corruption detection）：在栈帧中任何局部缓冲区和栈状态之间存一个随机产生的“金丝雀（canary）”值，规定为只读，检测其是否被修改 限制可执行的区域(limiting executable code regions)：栈可以被标记为不可执行区域 "},{"title":"CSAPP-Chap2 信息的表示和处理","date":"2024-06-27T15:17:40.000Z","url":"/2024/06/27/CSAPP/CSAPP-Chap2/","tags":[["C","/tags/C/"],["CSAPP","/tags/CSAPP/"],["X86-64","/tags/X86-64/"]],"categories":[["CSAPP","/categories/CSAPP/"]],"content":"信息存储大部分计算机使用8位的块（字节）作为访问内存单独的位。内存：很大的数组（虚拟内存(virtual memory)），字节位置即为地址 字数据大小每台计算机都有一个字长 (word size), 指明指针数据的标称大小 (nominal size)字长决定系统虚拟地址空间大小； 最近 32位-&gt;64位的迁移数据类型可能因为32位或者64位而大小不同(int, char, …)。 因此，C语言给了一堆特定大小的数据类型（int32_t, int64_t…） 寻址和字节顺序大端法和小端法：—最低有效字节在最前面的方式，称为小端法 (little endian)最高有效字节在最前面的方式，称为大端法 (big endian)网络传输数据可能有错误ps: typedef声明：给数据类型命名e.g.: typedef int *int_pointer; 布尔代数简介&amp;C语言中的按位计算![[Pasted image 20240630093522.png]]![[Pasted image 20240630093539.png]]| 就是 OR( 或），＆就是 AND( 与），～就是 NOT(反），而＾就是 EXCLUSIVE-OR( 异或&#x2F;XOR).逻辑运算：||, &amp;&amp; 和!：短路性，如果对一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。移位运算： &lt;&lt;和&gt;&gt; similar to 61C 整数表示&amp;小数表示参考[[61C-P2-number]] 整数运算加法：有符号数相当于把符号位变成了1，所以溢出时才会显示负数无符号位就相当于简单地减了2^w 对应labdata lab"},{"title":"61C-P5-CPU","date":"2024-06-25T06:47:18.000Z","url":"/2024/06/25/CS61C/61C-P5-CPU/","tags":[["61C","/tags/61C/"],["EE","/tags/EE/"],["CPU","/tags/CPU/"]],"categories":[["CS 61C","/categories/CS-61C/"]],"content":"SDS and boolean algebraSDSThe hardware underlying almost every processor is a Synchronous Digital System(SDS). Synchronous: All operations coordinated by a central clock Digital: Represent all values by discrete values— specifically, as binary digits 1 and 0 boolean signalsOn a chip&#x2F;PC board, wires (i.e., electrical nodes) provide electrical signals and are used to represent variables. A wire can take on different values at different points in time. Use voltage levels to signal 0 or 1 (why not choose 2 or more? good noise immunity; Moore’s Law;) Combinational Logic circuits Output is a function of the inputs only. Similar to a pure function in mathematics, y &#x3D; f(x). No way to store information from one invocation to the next, no side effectslogic gates: AND, OR and NOT![[Pasted image 20240626153741.png]]example: building a Equality Compare Circuit Recall the RISC-V instruction: beq rs1, rs2, label Truth Table -&gt; Gate Diagram: Construct the truth table for the function definition by enumerating all input&#x2F;output pairs. then, use the truth table to construct the gate diagram.![[Pasted image 20240627113159.png]]![[Pasted image 20240627113208.png]] boolean algebra![[Pasted image 20240627123736.png]] other logic gates![[Pasted image 20240627124743.png]]"},{"title":"61C-P4-CALL","date":"2024-06-24T06:47:18.000Z","url":"/2024/06/24/CS61C/61C-P4-CALL/","tags":[["61C","/tags/61C/"]],"categories":[["CS 61C","/categories/CS-61C/"]],"content":"CALL(Compiling, Assembling, Linking and Loading)p.s.: you can see [here](计组学习08——CALL - ZzTzZ - 博客园 (cnblogs.com)) for Chinese version for better understanding.![[Pasted image 20240624150906.png]]For C, compiling is actually multiple steps:compiling .c files to .o files,automatic assembling,then linking the .o files into executables. Step1: compilerinput: high-level language code (foo.c)output: assembly (foo.s)pseudo-intsturctions (伪指令) might be included Step2: assemblerinput: assemblyoutput: machine language module, object file (foo.o)Don’t know where the libs are located!!!objected file format: Object File Header Text Segment Data Segment Symbol Table: List of file’s labels, static data that can be referenced by other programs Relocation Information: Lines of code to fix later (by Linker) Debugging Information汇编器都会： 读取并且使用指令 把伪指令替换掉 产生机器语言 Assembler Directives 他们向汇编语言提供方向但是不产生机器指令 .text:在后面加上一些用户文本部分或者代码部分中的项目 .data：类似于text，除此之外把内容放在静态字段或者内存的数据段 .globl sym：声明 sym这个全局变量，并且可以被其他文件使用 .asciiz str: 把字符串str存储在内存里，也是以null终止 .word w1 w2 wn：接受由空格分割的整数或者单词，然后存储着n个32位量在连续的内存里替换伪指令：在之前已经举过例子了，会把一些伪指令替换成真正的指令 产生机器语言Simple case: Arithmetic, Logical, Shifts, etc. All necessary info is within the instruction already!PC-Relative Branches and Jumps: e.g., beq&#x2F;bne&#x2F;etc. and jal Position-Independent Code (PIC): Once pseudoinstructions are replaced with real ones, all known PC-relative addressing can be computed 简单的情况 算术或者逻辑指令，位运算都算比较简单的，交给计算机就好 因为所有的信息都在指令里 分支和跳跃呢？ 分支和跳跃需要相对地址 当我们把伪指令转化为真正指令的时候，我们会计算每条指令，并且弄清他们的去向这意味着我们会知道地址 如果跳跃到一些标签呢？ 分支控制语句可能跳转到一些以后的标签，我们还没有计算过地址的标签，甚至于汇编器都不知道这个标签的意义是什么，该怎么办呢？ 解决方案：让汇编器扫描两次，这样就都知道了 Pass 1: Remember positions of labels (store in symbol table). Pass 2: Use label positions to generate machine code 创建的为linker&#x2F;debugger的东西symbol table: list of ‘items’ in this object file 这些“东西”是指： 标签：函数调用 数据：所有在.data部分 变量可被文件访问 保持对标签的追踪解决了“前向关联问题” 重定位表（relocation table） 重定位表是一个用来存储文件里一会可能要用到地址的“东西” 这些“东西”是指： 任何拓展标签（jal，jar） 内部标签 internal 拓展标签 external (包括库文件) 认可数据段 比如任何在data部分提到的 step3 linkerinput: object files(foo.o)output: excutable machine code (a.out) 输入：目标文件（object file） 输出：可执行代码(Executable Code) 把多个目标文件组合成为一个可执行文件**(“linking”)** 可以进行单独的编译文件（非常有用！） 如果改变单个文件不需要重新编译整个项目![[Pasted image 20240625105533.png]]比如object file 1是我们的程序文件，object file 2是我们的库文件链接器可以把我们两个部分链接到一起 链接器将从每个.o文件中提取文本段然后把他们放在一起 把每个.o文件的数据段放在一起，之后把数据连接到文本段之后 解决所有引用 看重定位表并且处理其中每个条目 填写所有最终的绝对地址三种地址类型 相对PC的地址(beq, bne, jal) 不需要重定位，只要代码之间的相对位置不变，就不需要改变 外部函数的引用(往往都是jal) 往往需要重定位 静态数据的引用(往往都是auipc和addi) 往往需要重定位 RISCV经常用auipcRISC-V中的绝对寻址哪些指令需要重新定位编辑？ J格式的指令： jump &#x2F; jump and link 加载或者储存变量 到 静态区域里，和全局指针相关 条件分支，也是PC相关的，但是不用担心搬移，因为代码之间的相对位置没有改变 step4 loader (one of the tasks for OS)Load program into a newly created address space: Read executable’s file header for sizes of text, data segments Create new address space for program large enough to hold text and data segments, along with a stack segment. Copy instructions, data from executable file into new address space. Copy arguments passed to the program onto the stack. Initialize machine registers Most registers cleared; stack pointer (sp) assigned address of first free stack location Jump to start-up routine copy program arguments from stack to the registers, set PCif main routine returns, terminate programs with exit system call.a.out must contain both the machine code itself (text segment) and any static (data segment). interpretion vs translationinterpreter: Directly executes a program in the source language (slower for higher-level language)Translator: Converts a program from the source language to an equivalent program in another language (thus higher in efficiency)"},{"title":"PA1-notes","date":"2024-06-18T06:12:56.000Z","url":"/2024/06/18/PA/PA1-notes/","tags":[["CS","/tags/CS/"],["linux","/tags/linux/"],["ICS","/tags/ICS/"]],"categories":[["NJU PA","/categories/NJU-PA/"]],"content":"advanced makelscpu to see how many CPUs have in your computerthen, add -j? after the make to make the project run in multiple machinesccache: store the compiled file after it have been deleted by make clean PA1overviewWhat should be done in PA: using riscv-32 as ISA!CPU: central processing unit运算器 operator寄存器 容量小速度快； 存储器 容量大速度慢执行程序 –&gt; program counter(PC)the nature of computer: 计算机是一个状态机！ 时序逻辑部件（存储器，计数器，寄存器） 组合逻辑部件（加法器）程序也是一个状态机！静态视角：代码动态视角：状态机的转换monitor: 方便地监控客户计算机的运行状态most of the files’ function in the filelist: system configurationkconfig, a set of language to manage the systemmake menuconfig: 检查nemu/tools/kconfig/build/mconf程序是否存在, 若不存在, 则编译并生成mconf 检查nemu/tools/kconfig/build/conf程序是否存在, 若不存在, 则编译并生成conf 运行命令mconf nemu/Kconfig, 此时mconf将会解析nemu/Kconfig中的描述, 以菜单树的形式展示各种配置选项, 供开发者进行选择 退出菜单时, mconf会把开发者选择的结果记录到nemu/.config文件中 运行命令conf --syncconfig nemu/Kconfig, 此时conf将会解析nemu/Kconfig中的描述, 并读取选择结果nemu/.config, 结合两者来生成如下文件: 可以被包含到C代码中的宏定义(nemu/include/generated/autoconf.h), 这些宏的名称都是形如CONFIG_xxx的形式 可以被包含到Makefile中的变量定义(nemu/include/config/auto.conf) 可以被包含到Makefile中的, 和”配置描述文件”相关的依赖规则(nemu/include/config/auto.conf.cmd), 为了阅读代码, 我们可以不必关心它 通过时间戳来维护配置选项变化的目录树nemu/include/config/, 它会配合另一个工具nemu/tools/fixdep来使用, 用于在更新配置选项后节省不必要的文件编译, 为了阅读代码, 我们可以不必关心它we only need to care for the nemu/include/generated/autoconf.h (for reading C++ file) and nemu/include/config/auto.conf for reading makefile project building与配置系统进行关联通过包含nemu/include/config/auto.conf, 与kconfig生成的变量进行关联. 因此在通过menuconfig更新配置选项后, Makefile的行为可能也会有所变化. 文件列表(filelist)通过文件列表(filelist)决定最终参与编译的源文件. 在nemu/src及其子目录下存在一些名为filelist.mk的文件, 它们会根据menuconfig的配置对如下4个变量进行维护: SRCS-y - 参与编译的源文件的候选集合 SRCS-BLACKLIST-y - 不参与编译的源文件的黑名单集合 DIRS-y - 参与编译的目录集合, 该目录下的所有文件都会被加入到SRCS-y中 DIRS-BLACKLIST-y - 不参与编译的目录集合, 该目录下的所有文件都会被加入到SRCS-BLACKLIST-y中Makefile会包含项目中的所有filelist.mk文件, 对上述4个变量的追加定义进行汇总, 最终会过滤出在SRCS-y中但不在SRCS-BLACKLIST-y中的源文件, 来作为最终参与编译的源文件的集合.编译规则： the first user program 调用init_monitor()函数(在nemu/src/monitor/monitor.c中定义) 来进行一些和monitor相关的初始化工作 (parse_args(), init_rand(), init_log(),init_mem()) 调用init_isa()函数(在nemu/src/isa/$ISA/init.c中定义), 来进行一些ISA相关的初始化工作. 将客户程序(nemu/src/isa/$ISA/init.c)读到内存（uint8_t数组模拟）里（固定位置RESET_VECTOR） 现实生活中–bios初始化，再读程序运行 初始化寄存器(restart) :寄存器结构体CPU_state的定义放在nemu/src/isa/$ISA/include/isa-def.h中, 并在nemu/src/cpu/cpu-exec.c中定义一个全局变量cpu now, just run make run in the nemu directory. start running the first client programMonitor的初始化工作结束后, main()函数会继续调用engine_start()函数 (在nemu/src/engine/interpreter/init.c中定义). 代码会进入简易调试器(Simple Debugger)的主循环sdb_mainloop() (在nemu/src/monitor/sdb/sdb.c中定义) 在命令提示符后键入c后, NEMU开始进入指令执行的主循环cpu_exec() (在nemu/src/cpu/cpu-exec.c中定义) q to quit the loop 三个对调试有用的宏(在nemu/include/debug.h中定义) Log()是printf()的升级版, 专门用来输出调试信息, 同时还会输出使用Log()所在的源文件, 行号和函数. 当输出的调试信息过多的时候, 可以很方便地定位到代码中的相关位置 Assert()是assert()的升级版, 当测试条件为假时, 在assertion fail之前可以输出一些信息 panic()用于输出信息并结束程序, 相当于无条件的assertion fail 内存通过在nemu/src/memory/paddr.c中定义的大数组pmem来模拟. 在客户程序运行的过程中, 总是使用vaddr_read()和vaddr_write() (在nemu/src/memory/vaddr.c中定义)来访问模拟的内存. vaddr, paddr分别代表虚拟地址和物理地址. 这些概念在将来才会用到, 目前不必深究, 但从现在开始保持接口的一致性可以在将来避免一些不必要的麻烦.to sum up, 存储器是个在nemu/src/memory/paddr.c中定义的大数组 PC和通用寄存器都在nemu/src/isa/$ISA/include/isa-def.h中的结构体中定义 加法器在… 嗯, 这部分框架代码有点复杂, 不过它并不影响我们对TRM的理解, 我们还是在PA2里面再介绍它吧 TRM的工作方式通过cpu_exec()和exec_once()体现 基础设施"},{"title":"PA0-notes","date":"2024-06-17T13:08:45.000Z","url":"/2024/06/17/PA/PA0-notes/","tags":[["CS","/tags/CS/"],["vim","/tags/vim/"],["linux","/tags/linux/"]],"categories":[["NJU PA","/categories/NJU-PA/"]],"content":"Very Basic VimYou can edit /etc/vim/.vimrc for settingsorigin mode, insert mode, quit mode origin modemain usage:h,j,k,l for the movingi for entering insert modefor entering the quit modeinsert modejust like the origin windows one quit mode:w for saving:q for quitting MakefileBASIC rule:target file: dependent file instructions first example: hello world a more complicated one: testtarget: testorigin: program1.c program1.h program2.c program2.h main.c main.h some skills&#x3D;: simplifyingTAR = test : TAR can stand for test+&#x3D;: addingTAR += test1: TAR can not only stand for test, but also stand for test1:&#x3D;: always &#x3D;simplification of the example above: \\ %.o: any .o file*.o: all of the .o file can be simplified to $^: all dependent files$@: all target files$&lt;: all first files of the dependent files Basic GDB &amp; Valgrinda simple tool for debuggingsee [[61C-P0-debug]] for more! tmux a terminal multiplexer. It lets you switch easily between several programs in one terminal, detach them (they keep running in the background) and reattach them to a different terminal. sessionsstart exit or ^D create a session split sessions list sessions enter sessions kill sessions windowssplit windows 光标切换到上方窗格$ tmux select-pane -U光标切换到下方窗格$ tmux select-pane -D光标切换到左边窗格$ tmux select-pane -L光标切换到右边窗格$ tmux select-pane -R当前窗格上移$ tmux swap-pane -U当前窗格下移$ tmux swap-pane -D GitHub SSH in Linux then enter twice (if you want to set up the password, ignore that)your public key will be generated in /root/.ssh/id_exxxx.pubusing github, add the generated ssh key to your account, then OK other useful informationsaptitude is a useful tool for handling the dependency in linux!"},{"title":"functions","date":"2024-06-13T09:11:57.000Z","url":"/2024/06/13/CS106L/functions/","tags":[["Basic","/tags/Basic/"],["CPP","/tags/CPP/"],["functions","/tags/functions/"]],"categories":[["CS106L","/categories/CS106L/"]],"content":"template functionsfunctions whose functionality can be adapted to more than one type or class without repeating the entire code for each type."},{"title":"classes","date":"2024-06-13T09:11:33.000Z","url":"/2024/06/13/CS106L/classes/","tags":[["Basic","/tags/Basic/"],["CPP","/tags/CPP/"],["class","/tags/class/"]],"categories":[["CS106L","/categories/CS106L/"]],"content":"classstruct and classAll these fields are public, i.e. can be changed by the user.Because of this, we can’t enforce certain behaviors in structs, like avoiding a negative age.In class: users can access the public users cannot access the private define a classusing .h file! .h: define functions .cpp: implement logic.h file: .cpp file: List initialization constructor(C++11) destructor: All containers in STL are classes! Container adaptersthe container that Packaging a larger range of containers into a smaller range of that![[Pasted image 20240616210816.png]] Inheritancelike what mentioned in 61Bimplementation in C++:.h file difference between container adapters Subclasses inherit from base class functionality Container adapters provide the interface for several classes and act as a template parameter. template classesthis and is the same, but when initializing them? will crush!In the setX function we’re changing the member-variable value of x based on some passed in value.In getX we’re not modify anything, we’re just getting some value. implementation of template in C++template: to make the type a parameter while doing this, you also need to #include &quot;Container.cpp&quot; into the .h file. const interfaceObjects that are const can only interact with the const-interface.The const interface is simply the functions that are const&#x2F;do not modify the object&#x2F;instance of the class. overall example: IntArray.h file: .cpp file: main: problem? const IntArray&amp; arr! our at function didn’t provide ways for const! Casting: The process of converting types, there are many ways to do this.const_cast:const_cast&lt;target-type&gt; ( expression )We can use const_cast to cast away const-ness.So why is this useful Cast so that it is pointing to a non-const object Call the non-const version of the function (this is legal now) Then cast the non-const return from the function call to a const versio "},{"title":"cpp-containers-iterators","date":"2024-06-12T10:33:14.000Z","url":"/2024/06/12/CS106L/cpp-containers-iterators/","tags":[["Basic","/tags/Basic/"],["CPP","/tags/CPP/"]],"categories":[["CS106L","/categories/CS106L/"]],"content":"containerAn object that allows us to collect other objects together and interact with them in some way. (vectors, stacks, queues!)why containers? organization standardization abstractionwe have used the idea for structs: what if there are a whole class of students?Typically, containers export some standard, basic functionality. Allow you to store multiple objects (though all of the same type) Allow access to the collection through some (perhaps limited) way Maybe allow iteration through all of the objects May allow editing&#x2F;deletion STL containers vector stack queue set map array (fixed size of a vector) deque (double ended queue) list (DLList) unordered set unordered map vector![[Pasted image 20240612185423.png]]additionally: why C++ is fast? Only provide the checks&#x2F;safety nets that are necessary the programmers knows best! implementationkeep track of a few member values: size &#x3D; number of elements in the vector capacity &#x3D; space allocated for elements unordered maps&#x2F;setsneed a hash function to be definedfaster thant ordered maps&#x2F;sets(needs a comparison operator) hashingas mentioned in 61B 2 types of containerssequenceanything with a inherent ordercontainers can be accessed sequentially associative don’t necessarily have a sequence more easily searched maps and sets! how to choose containers![[Pasted image 20240612190037.png]]Sequence containers are for when you need to enforce some order on your information! vector for most anything fast inserts in the front: std::deque joining&#x2F;working with multiple lists: std::list (rare) container adaptorsContainer adaptors are “wrappers” to existing containers!modify the interface to sequence containers and change what the client is allowed to do&#x2F;how they can interact with the containere.g.: wrap the queue from a dequeWhy? abstraction! iteratorsimilar to what have been taught in 61Bin the STL: initializing –&gt; iter = s.begin(); invermenting –&gt; ++iter; (iter++ will return the previous value!) dereferencing –&gt;*iter; comparing –&gt; iter !&#x3D; s.end(); copying –&gt;new_iter &#x3D; iter;![[Pasted image 20240613113558.png]] ![[Pasted image 20240613170004.png]]forward iterator: Input iterators can appear on the RHS (right hand side) of an &#x3D; operator like auto elem = *it; output iterators can appear on the LHS like *elem = value;bidirectional iterator: can go backward, like --iter;random access iterator: directly access values without visiting all of the elements, like iter += 5;All iteration time in the iterator is constant! pointeractually, iterator is a particular type of container!‘point’ at the particular elements in the containerPointers are marked by the asterisk * next to the type ofthe object they’re pointing at when they’re declared.The address of a variable can be accessed by using &amp; before its name, same as when passing by reference!"},{"title":"Cpp-types, structs, ini, ref, streams","date":"2024-06-08T06:49:37.000Z","url":"/2024/06/08/CS106L/Cpp-types-structs/","tags":[["Basic","/tags/Basic/"],["CPP","/tags/CPP/"]],"categories":[["CS106L","/categories/CS106L/"]],"content":"very basic STL std:::The STL Tons of general functionality Built in classes like maps, sets, vectors Accessed through the namespace std:: Extremely powerful and well-maintainedusing namespace std; is not a good style! typesmore fundemental types: std::string str = &quot;Haven&quot;;C++: a interpreted language (Types before program runs during compilation)C++ allows function overloading!auto: a keyword that tell the compiler to deduce the type of a object or a varible only use when the types are obvious or when the type is annoyingly verbose to write out structsSTL have its own structs!std::pair: struct with 2 fields of any type(first and second) initialization what is wrong?42.5 is not a int, but C++ not care.C++ not check with ini value, so it might cause narrowing conversation. uniform ini (C++11)int numOne&#123;12.0&#125;; with these uniform ini, C++ does care about types!features: safe: do not allow for narrowing conversions ubiquitous: works for all types! structures ini structure binding (C++17) l-values and r-valuesI-values(左值): can appear both in the right and left sides of the equations (not temp!)r-values(右值): can appear only in the right hand side of the equations (temp.!) constto declare a value to be a r-valuecannot declare a non-const reference to a const value! compilingg++ -std=c++11 main.cpp -o maing++ -std=c++11 main.cpp is also OK (resulting in a.out in linux) Streama general input&#x2F;output abstraction for C++![[Pasted image 20240612182503.png]]known as iostreams!cout, cin: no need to saycerr: output errorsclog: non-critical event loggingInput streams (I) a way to read data from a source Are inherited from std::istream ex. reading in something from the console (std::cin) primary operator: &gt;&gt; (called the extraction operator)Output streams (O) a way to write data to a destination Are inherited from std::ostream ex. writing out something to the console (std::cout) primary operator: &lt;&lt; (called the insertion operator) stringstreamsa way to treat string as streams what if we want the extracted_quote to be the rest? the &gt;&gt; only read till the blank, so we tend to use getline()! output streamsstd::endl: tells the cout stream to end the line!also tells the stream to flush(冲厕所) buffer: 5 ‘\\n’ buffer:1 ‘\\n’ 2 ‘\\n’ 3 ‘\\n’ 4 ‘\\n’ (until it is full, it releases)5 &#39;\\n&#39; file systemsstd::ofstream input streamscin reads up to white spacewhen cin fails: it cannot find the corresponding value until the next whitespace!In conclusion: Streams are a general interface to read and write data in programs Input and output streams on the same source&#x2F;destination type compliment each other! Don’t use getline() and std::cin() together, unless you really really have to! "},{"title":"61C-P3-RISC-v","date":"2024-05-28T03:10:11.000Z","url":"/2024/05/28/CS61C/61C-P3-RISC-v/","tags":[["61C","/tags/61C/"],["Assembly","/tags/Assembly/"]],"categories":[["CS 61C","/categories/CS-61C/"]],"content":"Assembly languagedefinition Different CPUs implement different sets of instructions. The set of instructions a particular CPU implements is an Instruction Set Architecture (ISA), and the programming language defined by the ISA is commonly known as an assembly language. Examples: ARM (cell phones), Intel x86 (i9, i7, i5, i3), IBM&#x2F;Motorola PowerPC (old Macs), MIPS, RISC-V, … risc-vCS 61C Reference Card  Lists out the entire base architectureVenus  Online RISC-V simulator overall viewsystem: CPU: compute things fast; but store little data main memory: store more data, but access much slower than computed. register A register is a CPU component specifically designed to store a small amount of data. Each register stores 32 bits of data (for a 32-bit system) or 64 bits of data (for a 64-bit system). For the purposes of this class, we consider RV32 only (which uses 32-bit registers) This data is purely binary; types do not exist at the assembly level Registers are a hardware component, so once you make the CPU, you can’t change the number of registers available. Can’t “make” a new register when defining a new variable; have to delete an existing register for each variable you make. RISC-V gives access to 32 integer registers: x0-x31 x0 always stores 0, so only 31 registers are available to hold varibles instructions![[Pasted image 20240627160611.png]]Each line of RISC-V code is a single instruction, which executes a simple operation on registersin the format: &lt;instruction name&gt; &lt;destination register&gt; &lt;operands&gt; Ex. “add x5 x6 x7” means “Add the values stored in x6 and x7, and store the result in x5” Commas can be added between registers (“add x5, x6, x7”), but this is optional.for comments: # ...Far more important than in other languages!!! additionadd x1, x2, x3 &#x3D;&#x3D; a = b + c (x1 -&gt;a, x2 -&gt; b, x3 -&gt; c) subtractionsub x3,x4,x5 &#x3D;&#x3D; d = e - fexercise: do a = b + c + d - e; do f = (g + h) - (i + j); Immediatesnumerical constantsadd immediate: addi x3, x4, 10 &#x3D;&#x3D; f = g + 10No subtract immediates in RISC-V! load immediateli rd, imme.g.: li rd, 5 &#x3D;&#x3D; addi rd, x0, 5 register 0add x3, x4, x0 &#x3D;&#x3D; f = g data transfermain memory![[Pasted image 20240529085310.png]] 4 bytes together make a word RISC-V uses little-endian to store data: The least significant byte gets stored at the lowest address. load wordlw rd imm(rs1): Compute imm+rs1, then load the 4 bytes at that address into rdexample: lw x10 12(x5) 0x100+12&#x3D;0x10C bytes at 0x10C-0x10F: 0x53, 0x42, 0x56, 0x00 32-bit valurte 0x0056 4253 store wordsw rs2 imm(rs1): Compute imm+rs1, then store the 4 bytes of rs2 into that address.e.g.: sw x10 0(x5) if x5 is 0x100, x10 is 0x1234 5678 0x100+0 &#x3D; 0x100 Since RISC-V is little-endian, the 32-bit value 0x1234 5678 gets split into bytes 0x78 0x56 0x34 0x12 So the bytes in memory 0x100, 0x101, 0x102, and 0x103 get set to 0x78, 0x56, x34, and 0x12, respectively. load bytelb rd imm(rs1) store bytesb rs2 imm(rs1) example: converting C code to RISC-VC: RISC-V: control flownew C operatorlabelA label is an identifier to a particular line of code Doesn’t count as a line of code itself; merely “points out” a particular line Each label must have a unique name (like variable names) gotoThe goto statement changes the next line to be run to the labelled line The label can be either before or after the goto statement.never use goto!!! goto has a tendency to create completely illegible code Generally considered bad practice, except in very specific situations Error handling Jumping out of nested loopssimple example of goto: RISC-V instructions for control flowList of branch instructions: beq rs1 rs2 Label: Branch if EQual bne rs1 rs2 Label: Branch if Not Equal blt rs1 rs2 Label: Branch if Less Than (signed) (rs1 &lt; rs2) bge rs1 rs2 Label: Branch if Greater or Equal (signed) bltu rs1 rs2 Label: Branch if Less Than (unsigned) bgeu rs1 rs2 Label: Branch if Greater or Equal (unsigned)example: bitwise operationsreview: C bitwise operations: AND, OR, XOR, and NOT: perform the operation one bit at a time left and right shift: shift the bits of the number left&#x2F;rightshift have numerial equivalents in math left shift: multiply by $2^n$ –&gt; fill the new bits with 0s right shift by n -&gt; floor divide by $2^n$ –&gt; dividing an unsigned number should fill the bits with 0s; signed numbers fill with the sign bit RISC-V operationsadd rd rs1 rs2: Addsub rd rs1 rs2: Subtractand rd rs1 rs2: Bitwise ANDor rd rs1 rs2: Bitwise ORxor rd rs1 rs2: Bitwise XORsll rd rs1 rs2: Shift Left Logical (rd left rs2 digit, left using the highest of rs1)srl rd rs1 rs2: Shift Right Logicalsra rd rs1 rs2: Shift Right Arithmeticso far: ![[Pasted image 20240617151458.png]] preceduresC functions: Calling a function: Set function arguments Goto the start of the functionDuring a function call: Keep local scope separate from global scope Perform the desired task of the functionReturning from a function: Place the return value in a variable that can be accessed Goto the line immediately after the function call problems in RISC-Vmaintaining scopeIn RISC-v, however, local scope do not exist. Therefore, we need a way to store variables that no called function can change returning from a functionWe’ll need a way to send in the return address to a function, and jump to that return address when we finish with the function memory model of RISC-Valmost the same as CProgram is also a kind of data. It stored in text section of the memory.in RISC-v: every (real) instruction is stored as a 32-bit number A special 33rd register called the Program Counter (or PC) keeps track of which line of code is currently being run jumps: jump to the address of the instruction jal rd label: jump and link: jump to the given label and sets rd to PC+4 (for function calls) j label: jump to the given label; used for unconditional jumps jalr rd rs1 imm: Jumps to the instruction at address rs1+imm, and sets rd to PC+4 (used for higher-order functions and some function calls) jr rs1: jump to the instruction at address rs1 (return from a function) stackOne of our registers (by convention x2, nicknamed sp, or “stack pointer”) is set to the bottom of the stack. A function can choose to create a stack frame, by manipulating sp. Anything above the sp at the start of a function belongs to another function. You may not modify anything above the sp without permission. Everything below the sp is safe to modify. But anyone else can modify it, so you can’t leave data there and expect it to stay the same By decrementing the sp, we can allocate as much space as we need for our function, that we can use however we want. After finishing a function call, the sp must be set to its value from before the function call自己的理解：相当于寄存器sp存储了一个栈的底部，然后当调用函数时将这个栈的底部向下移一定的位数形成自己的栈（addo sp sp -8），调用玩了之后再把sp还原回原来的位置 converting a C function into RISC-Vthe function is: step1: define how the function plans to use registersInputs:i: x10 We’ll call this register “a0” for “argument”Return Address: x1 We’ll call this register “ra”Output: x10 (Yes, we’ll reuse a0 for the return value)Stack Pointer: x2 Nicknamed “sp”Register that will NOT be changed by foo: x8, x9 We can still use these registers, as long as they get restored by the end of the function We’ll call these registers “s0” and “s1” for “saved” the function foo: calling conventionStandardize a set of conventions that everyone agrees to follow in the functions of each register![[Pasted image 20240623140053.png]] zero: The x0 register, which always stores 0 ra: x1, which is used to store return addresses Two new pseudoinstructions that explicitly use this: jal Label -&gt; jal ra Label ret -&gt; jr ra sp: The x2 register, which is the stack pointer s0-s11: Saved registers Registers that do not need to be restored by a called function (i.e. if you want to save a variable in this register, it needs to be saved somewhere before you call another function) a0-a7: Registers used for function arguments a0, a1 also used for function outputs If a function needs more than 8 arguments, can use the stack to store more arguments t0-t6: temporary Registers gp: The x3 register, used to store a reference to the heap. Also called the “global pointer” tp: The x4 register, used to store separate stacks for threads all remaining RISC-V instructions slt, slti, sltu, sltiu: Set Less Than slt rd rs1 rs2: Compares rs1 to rs2. If rs1 &lt; rs2 (signed), sets rd to 1. Otherwise sets rd to 0. lh, lhu, sh Load&#x2F;Store Halfword: Same as lb&#x2F;lbu&#x2F;sb, but for 2-byte blocks ebreak, ecall: Environment Break&#x2F;Call Asks the computer to do something (ex. Print data, set a breakpoint for debugging, allocate heap space) We’ll provide utility functions that call ecall&#x2F;ebreak for you lui, auipc: will be mentioned in the following part! RISC-V Instruction Formats简单的概括： 程序也是数据，研究存储程序的数据![[Pasted image 20240624121656.png]] R-types![[Pasted image 20240624121306.png]] Designed for instructions with 3 registers and no immediate Arithmetic operators like add or sub Each register is identified by its number. 32 registers → 5 bits to identify one register uniquely 0x0 → 0b00000 a0 → x10 → 0b01010 opcode: Instruction identifier: Always the last 7 bits of the instruction over all instruction formats Can therefore be used to determine which instruction format is currently in use. Some sets of similar instructions get assigned the same opcode Ex. All arithmetic R-type instructions have the opcode 0x33 funct3: 3-bit identifier to differentiate instructions with the same opcode funct7: Extra 7-bit identifier for extremely similar instructions with the same opcode and funct3 (such as sra and srl) ![[Pasted image 20240624121449.png]] I-type![[Pasted image 20240624121318.png]]Designed for instructions with 2 registers (rs1 and rd) and 1 immediate Most components are stored the same way as before, with the addition of the imm component Most instructions use signed immediates, so our range for I-type immediates is [-2048,2047].![[Pasted image 20240624121541.png]]![[Pasted image 20240624121526.png]]![[Pasted image 20240624121549.png]] S-type![[Pasted image 20240624121639.png]]similar to I-type, but store the immediate separately![[Pasted image 20240624121726.png]] U-type![[Pasted image 20240624143102.png]] Load Upper Immediate: lui rd imm Sets rd to imm &lt;&lt; 12 example: How would you translate “li t0 0xABCDEFFF” to instructions? lui t0 0xABCDF #t0 stores 0xABCDF000 addi t0 t0 0xFFF #t0 stores 0xABCDEFFF Upper Immediate to Program Counter: auipc rd imm Sets rd to (imm &lt;&lt; 12) + PC Primarily used in two pseudoinstructions: li rd imm: Set rd to imm la rd Label: Set rd to the address of Label ![[Pasted image 20240624143227.png]] B-type![[Pasted image 20240624143201.png]] Branch instructions also use 2 source registers and an immediate, so the format is similar to S-Type This format is sometimes referred to as SB-type for that reason Note that the immediate is stored in a strange pattern If we had the binary 0bA BCDE FGHI JKLM (where each letter was a bit), the first box would store 0bACD EFGH and the second box would store 0bI JKLB. Bit M isn’t stored. This is also to simplify the underlying circuit; note that we put the MSB of our immediate in the MSB of our instruction (to simplify sign-extension), and other than that put 10 of the remaining 11 bits in the same position as S-type instructions Branch instructions have 13-bit immediates &#x3D; [-4096, 4094] range, which is up to 210 instructions up&#x2F;down.![[Pasted image 20240624143551.png]] J-types![[Pasted image 20240624143745.png]] Jal instructions use only 1 destination and an immediate, so we can use the U-type format for extra immediate bits This format is sometimes referred to as UJ-type for that reason Note that the immediate is stored in an even stranger pattern If we had the binary 0bA BCDE FGHI JKLM NOPQ RSTU (where each letter was a bit), the data would be stored as 0b AKLM NOPQ RSTJ BCDE FGHI. As before, the last bit isn’t stored Note that we put the MSB of our immediate in the MSB of our instruction, bits 19-12 in the same spot as U-types, and bits 10-1 in the same spot as I-types. Jumps have 21-bit immediates, so up to 218 instructions up&#x2F;down summaryyou can get the summary card here."},{"title":"61C-P2-number","date":"2024-05-23T03:10:54.000Z","url":"/2024/05/23/CS61C/61C-P2-number/","tags":[["61C","/tags/61C/"],["BasicC","/tags/BasicC/"]],"categories":[["CS 61C","/categories/CS-61C/"]],"content":"binarybasics A system of storing data using just two digits: 1 and 0. Everything in a computer is ultimately stored in binary (high voltage wire &#x3D; 1, low voltage wire &#x3D; 0) Generally rooted in the mathematical concept of binary (as a base 2 system of representing numbers) Since computers tend to “think” in binary, it is ultimately useful to work with values in binary. By convention we prepend any binary value with “0b” operations&amp;, |, ~, ^: convert every&lt;&lt;, &gt;&gt;: Left shift: Convert to binary, then move all bits left, appending 0s as needed (Equivalent to multiplying by a power of 2) Right shift (logical): Convert to binary, then move all bits right, prepending 0s as needed (Equivalent to dividing by a power of 2)for example:![[Pasted image 20240523104246.png]] signed numbers![[Pasted image 20240523110950.png]]Formally: Define a “bias” To interpret stored binary: Read the data as an unsigned number, then add the bias To store a data value: Subtract the bias, then store the resulting number as an unsigned number floatfixed point representation![[Pasted image 20240523113405.png]]but what about other numbers? very large number (31,556,926,010 (3.155692610 x 10^10)) very small number (0.000000000052917710 (5.2917710 x 10^-11)) floating pointIEEE standard 754!Take scientific notation as an example:![[Pasted image 20240526155108.png]]Similarly, the floating point method are as the $A*2^B$ 1 bit: sign bit 8 bits: exponent (B) 23 bits: significand(A)$(-1)^s*(1+significand)*2^{exponent-127}$ sth. special0zero have no normalized representation!(all zeros) large &amp; small numbers255 is the same as 0? –overflow (more than 3.4* 10^38!) &amp; underflow (less than 1.2* 10^-38!) ! $\\pm \\infty$IEEE standard: export 1111 1111 , significand zero for $\\pm \\infty$ not a number(NaN)export 1111 1111, significand nonzero. Another problem: there is a gap between FP numbers and zero! smallest normalized number: $2^{-126}$ smallest number between 2 numbers: $2^{-149}$Solution: denormalized number( no (implied) leading 1; implicit exponent for all denorms &#x3D; -126)You can see [here](IEEE-754 Floating Point Converter (h-schmidt.net)) for IEEE 754 float transformation other floating point representationsdouble precision floating pointextend the 16 bits to 32 bits!sign 1bits; exponent 11bits; significand 20bits!"},{"title":"61C-P0-debug","date":"2024-05-22T02:06:11.000Z","url":"/2024/05/22/CS61C/61C-P0-debug/","tags":[["debugging","/tags/debugging/"],["61C","/tags/61C/"],["BasicC","/tags/BasicC/"],["GDB","/tags/GDB/"]],"categories":[["CS 61C","/categories/CS-61C/"]],"content":"gdbGDB commands:![[Pasted image 20240522101140.png]]![[Pasted image 20240522101153.png]] valgrindbugs: bohrbug: can appear in certain conditionsheisenbugs: cannot appear in the debugging processWe can use a tool called Valgrind to help catch to help catch “heisenbugs” and “bohrbugs”.emulates your CPU and tracks your memory accesses! "},{"title":"61C-P1-C","date":"2024-05-17T03:10:54.000Z","url":"/2024/05/17/CS61C/61C-P1-C/","tags":[["61C","/tags/61C/"],["BasicC","/tags/BasicC/"]],"categories":[["CS 61C","/categories/CS-61C/"]],"content":"Compilegcc hello.ccreates machine language codea.out loads andexecutes programgreat idea in C:![[Pasted image 20240519124500.png]] basic grammarsinput Combined, argc and argv get the main function to accept arguments. argc will contain the number of strings on the command line (the executable counts as one, plus one for each argument). Here argc is 2: ./a.out myFile argv is a pointer to an array containing the arguments as strings (more later re: pointers and strings). output %X is for hexadecimal (16-dimension) numeralEverything on your computer is bits. basic types Type Description Example int Integer Numbers (including negatives) 0, 78, -217, 0x7337 unsigned int Unsigned Integers (i.e., non-negatives) 0, 6, 35102 float Floating point decimal 0.0, 3.14159, 6.02e23 double Equal or higher precision floating point 0.0, 3.14159, 6.02e23 char Single character ‘a’, ‘D’, ‘\\n’ long Longer int, Size &gt;&#x3D; sizeof(int), at least 32b 0, 78, -217, 301720971 long long Even longer int, size &gt;&#x3D; sizeof(long), at least 64b 3170519272109251 boolean: true&amp;false false: 0 (for ints, all varibles are 0) NULL(pointers) more featuresconstants in Cconst int a = 1; assigned the 1 to a in the declaration and never change it throughout the program#define a 1 give 1 to a prior to all of the compilation process typedefdefining new types are allowed. structstrurcted objects control flowthe same as that in Java! pointersmemorymemory is basically a big single-array.A pointer refer to the location of the memory. pointers usagePointers are useful when passing parameters. good ones: common bugs: garbage addressLocal variables in C are not inialized!Therefore, they can be anything. structs arraysjust a big block of memory!declaration and ini: the same as that of java pointers for arraysa[i] ⟺ *(a+i) they are equal! pointer changingwrong code: printed: q &#x3D; 50!remember: C is pass by value!Instead, pass a pointer to a pointer (“handle”).: Declared as data_type **h.right code: common pitfallsconstant using of an numberWrong Strongly encouraged arrays VS pointerschar *string &#x3D; char string[]accessing array elements:arr[0] is equal to *arrarr[2] is equal to *(arr+2) other features array bounds are not checked during the element access! An array is passed into functions as a pointer declared arrays are only allocated while the scope is valid. StringsAn array of characters,followed by a null terminator. aka \\0C have a branch of functions for string: strlen: computes the length of a string strcpy: copy a string from one to another endianness“little endian”: the least significant byte of a value is stored first“big endian”: contradict to little ones memorysizeof(): gives size in bytes of types of varible address space Stack: local variables inside functions, grows downward Heap: space requested via malloc(); resizes dynamically, grows upward Data (Static Data): variables declared outside main, does not grow or shrink Text (aka code): program executable loaded when program starts, does not change chunk is unwriteable&#x2F;unreadable so you that crash on NULL pointer access![[Pasted image 20240520110032.png]]Programming in C needs to know the memory!Global: stored in data framelocal: stored in the stack, and then released after the function have been used. stackevery time a function is called, the stack is established.Last in, first out! pointers in the stackIt is ok and fine to pause pointers outside into the stackHowever, it is bad to return a pointer to sth. in the stack! heapdynamic memory–&gt;&gt; the stack!specify number of memory can be allocated&#x2F;disallocated malloc(): Allocates raw, uninitialized memory from heap free(): Frees memory on heap ealloc(): Resizes previously allocated heap blocks to new size malloc()return void * pointer to blocks of memoryallocate a sturct: allocate an array of 20 ints: free()dynamically free the memory realloc()resize a previously allocated block at a new size![[Pasted image 20240521110437.png]]⚠ Memory can be allocated &#x2F; deallocated at any time! “Memory leak”: If you forget to deallocate memory “Use after free”: If you use data after calling free “Double free”: If you call free 2x on same memory memory leakthe failure to free()! use after free double free forgetting realloc()realloc() copy the data into a different part of the heap. more pointersfunction pointersint (* fn) (void * , void * ) = &amp;foo; fn is a function that accepts two void * pointers and returns an int and is initially pointing to the function foo.(* fn)(x, y); will then call the functionexample: generic functionswhy? – we want to write general-purpose codegenerics: Should generally work regardless of argument type Update blocks of memory, regardless of data type stored in those blocksone example:![[Pasted image 20240527174041.png]] generic memory copyingTo access some number of bytes in the memory, we use 2 generics in the String standard library: void *memcpy(void *dest, const void *src, size_t n): copy n bytes from memory area src to memory area dest, return a pointer to dest memmove(void *dest, const void *src, size_t n): copy n bytes from memory area src to the memory area dest, return a pointer to dest.use memcpy for performance reasons! example: swapconsider swapsome swaps: consider other swaps: short swap, string swap, char swap…void* swap can be a “general swap”! another example: swap_ends"},{"title":"61B-P5-6-sort","date":"2024-05-15T15:19:17.000Z","url":"/2024/05/15/61B/61B-P5-6-sort/","tags":[["Java","/tags/Java/"],["61B","/tags/61B/"],["sorting","/tags/sorting/"]],"categories":[["CS 61B","/categories/CS-61B/"]],"content":"definitionsAn ordering relation &lt;&lt; for keys a, b, and c has the following properties: Law of Trichotomy: Exactly one of a &lt;&lt; b, a &#x3D; b, b &lt;&lt; a is true. Law of Transitivity: If a &lt;&lt; b, and b &lt;&lt; c, then a &lt;&lt; c. Java: ComparableIn java, compare or compareTo methods are used. basic sortsselection sort Find the smallest item. Swap that item to the front. Repeat until all items are fixed (there are no inversions).runs in Θ(N^2) time heapsort insert all the items into a max heap and create and output array. Then, we repeatedly delete the largest item from the max heap and put the largest item at the end part of the output array.overall running time: Θ(𝑁log⁡𝑁) Inserting N items into the heap: 𝑂(𝑁log⁡𝑁). Selecting the largest item: Θ(1). Removing the largest item: 𝑂(log⁡𝑁). in-place heapsortinstead of constructing a totally new heap, exchange the array to make them in order of the heap.we can use a process known as bottom-up heapification to convert the input array into a heap. Bottom-up heapification involves moving in reverse level order up the heap, sinking nodes to their appropriate location as you move up. Bottom-up heapify input array: Sink nodes in reverse level order: sink(k) After sinking, guaranteed that tree rooted at position k is a heap. Repeat N times: Delete largest item from the max heap, swapping root with last item in the heap. ![[Pasted image 20240516104440.png]] merge sort Split the items into half. Mergesort each half. Merge the two sorted halves to form the final result. insertion sort divide the “sorted” part, and the “unsorted” part find a element in unsorted part, and then insert it into the sorted part. quicksortsimple quicksortThe core idea behind Quicksort involves partitioning.Partitioning on that pivot element (x) involves rearrange a[] such that: x moves to some position j (can be the original position of i) All array elements to the left of x are less than or equal to x (&lt;&#x3D; x) All array elements to the right of x are greater than or equal to x (&gt;&#x3D; x)then, call quicksort recursively, and the quicksort have been done.Coincidentally, quicksort is empirically the fastest sort for most common situations. complexitybest: O(nlogn)worst: O(n^2) drawbacksthe choosing of the split point is more than important! improvementrandomness pick pivots randomly shuffle items before sort Smarter Pivot Selectionto choose a “good” pivot constant time pivot pick: pick up a few items and then choose the “best” one among them linear time pivot pick: always select the “median” "},{"title":"61B-P5-5-QuadTree","date":"2024-05-15T07:15:38.000Z","url":"/2024/05/15/61B/61B-P5-5-QuadTree/","tags":[["Java","/tags/Java/"],["61B","/tags/61B/"],["QuadTree","/tags/QuadTree/"]],"categories":[["CS 61B","/categories/CS-61B/"]],"content":"questionSuppose we want to perform operations on a set of Body objects in space. For example, perhaps we wanted to ask questions about the Sun bodies (shown as yellow dots below) in our two-dimension image space.How many objects are in a region? HashTableiterate over all items to checkproblem: totally random! uniform partitioningOur attempt is to ensure that the bucket numbers depend only on position! uniformly partition our image space by throwing a 4x4 grid over it (“spatial hashing”) implementation: provide a getX() and getY() function. On average, the runtime will be 16 times faster than without spatial partitioning, but unfortunately 𝑁&#x2F;16 is still Θ(N). BUT, this does indeed work better in practice. QuadTreesKey advantage that BST better than HashTable is that the trees track the order of items.However, the objects in multiple dimensions can be both “lesser” and “greater” than the other subject.Therefore, we choose to separate the tree children into 4.![[Pasted image 20240515230236.png]]Here, we see that node A splits its surrounding area into a northwest, northeast, southeast, and southwest region. Since E resides in the northeast quadrant of A, when we insert E, we can put it as a child of A as its NE child. higher dimension: KD TreeIt works by rotating through all the dimensions level by level. constructionTake 2-dimension tree as an example: X-based tree at the first level, and then the Y-based tree on the second level, and then the X-based tree at the third level…a K-D tree will always be a binary tree, since each level is partitioned into “greater” and “less than”. search Start at the root and store that point as the “best so far”. Compute its distance to the query point, and save that as the “score to beat”. This node partitions the space around it into two subspaces. For each subspace, computing the shortest distance between the query point and the edge of our subspace. Continue recursively for each subspace identified as containing a possibly better point.![[Pasted image 20240515231753.png]] "},{"title":"C++-intro","date":"2024-05-10T07:06:45.000Z","url":"/2024/05/10/VG101/Cpp-intro/","tags":[["Basic","/tags/Basic/"],["CPP","/tags/CPP/"]],"categories":[["Engineering 101","/categories/Engineering-101/"]],"content":"C BasicsWhat C++ brings: Almost all the aspects of C are preserved New features are added, e.g., templates, references Sophisticated programs are easier to code, thanks to OOP C++ is almost a superset of Cnew data types: bool a = false, b = true;new headers: new I&#x2F;O style: input: cin &gt;&gt; x output: cout &lt;&lt; &#39;string&#39; formatting output: setw(int width): set the width of the output setfill(z): set up the prefix (前缀) of the output setprecision(2): set up the precision of the output pointers for C++No more malloc, calloc and free: Memory for a variable: int *p = new int; Memory for an array: int *p = new int[10]; Array size can be a variable (not recommended in C) Return NULL on failure (nullptr in mordern C++) Release the memory: delete p or delete[] p pass-by-reference is an additional way to pass an address into a function strings other string operations: String operations (insert, erase, repllace, swap, copy, finnd, substr) File I&#x2F;ORequires header: #include &lt;fstream&gt; Open file for reading: ifstream in; in.open(&quot;file.txt&quot;); Open file for reading in short: ifstream in(&quot;file.txt&quot;) Read from a file: in used in the same way as cin Open a file for writing: ofstream out(&quot;file.txt&quot;) Write in a file: out used in the same way as cout Read from a file, line by line, into a string s: getline(in,s) OOPobject-oriented programmingA new approach: Everything is an object Objects communicate between them by sending messages Each object has its own type Object of a same type can receive the same message objecttwo main components: Its behavior, what can be done with it, its methods The data it contains, what it knows, its attributes ClassDefines the family, type or nature of an objectEquivalent of the type in “traditional programming” visibilityPrivate or public: Private members can only be accessed by member functions within the class Users can only access public membersexample: implementationGetting things ready: Class interface is ready Instantiation is possible Does not compile: no implementation of the class yet Syntax: classname::methodnameexample: constructorA constructor is a member function&#x2F;method with the following properties: If a class has a constructor, a constructor is called automatically whenever an instance of the class is declared. The name of a constructor must be the same as the name of the class. A constructor does not have any return value. void or other return type all not allowed.example: thisMethods access the object on which they were called through an extra, implict parameter named this, which is initialized with the address of the object on which the method was invoked InstanceRealisation of an object from a given classEquivalent of a variable in “traditional programming” overloaddefinitions: Two constructor defined: circle() and circle(float) Proper one automatically selected inheritancePrivate inheritance: Default type of class inheritance Any public member from the base class becomes private Allows to hide “low level” details to other classesTherefore, protected burn.Protected members: Compromise between public and private - They are available to any derived class No other class can access themfriend: bypass all this security of the classavoid using it!! virtualSometimes we have to create a pointer to the base class that refers to all the derived objects. When the base class pointer contains the derived class address, the object always executes the base class function. Therefore, virtual born to address the drawback. Virtual function in the base class Function can be redefined in derived class Preserves calling propertiesexample: "},{"title":"C-intro","date":"2024-05-10T07:06:34.000Z","url":"/2024/05/10/VG101/C-intro/","tags":[["Basic","/tags/Basic/"],["CPP","/tags/CPP/"]],"categories":[["Engineering 101","/categories/Engineering-101/"]],"content":"Basic Linux tar usagetar -xvf xxx.tar unziptar -cf xxx.tar ... xxx.c zip basic data typesInteger: intCharacter: charValueless type: voidFractional numbers: Singleprecision: floatDouble precision: doubleVarious types variations:char: signed char, unsigned charint: short int, signed short int, unsigned short int, signed int, unsigned int, long int, signed long int, unsigned long int, long long int, signed long long int, unsigned long long intdouble: long double Basic number typesfloat: 7 digits of precision, from 1 10^-38 to 3 10^38double: 13 digits of precision, from 2 10 ^-308 to 1 10^308 CharactersCharacters are enclosed in single quotes,e.g.char a=’a’;Character are encoded using the American Standard Codes for Information Interchange(ASCII)C do not have a string type, instead strings are viewed as arrays of characters(explanation later)Strings are enclosed in double quotes Arithmetic operator+,-, *, &#x2F;except %, all arithmetic operator acceptes floating number!Difference between i += j; and i =+ j;?first &#x3D;&#x3D; i = i + j; second &#x3D;&#x3D; i = j; logic statementif…else switch loopfor while do-while do will execute the statements at least once.break, continue are also useful getchar() and putcharCharacter specific I&#x2F;Ogetchar(): reads one character (in the input zone) and return this characterputchar(cha): prints one character cha conditional operatorThe only ternary operator in C: condition ? expression1 : expression2 arrayis series of values following the same data type, and stored sequentiallyIn C an array is defined by three parameters: The data type of its elements A name A size, i.e. the number of elements compositing itArray index starts from 0!!!sizeof can be used to calculate the size of an array by byte. multidimensional arraysInitializing: int m[5][9] = &#123;&#123;1,1,1,1,1&#125;, &#123;1,1,1,1,1&#125;&#125;;Not large enough to fill in the array, remaining will be zeroDesignated initializers: double indent[2][2] = &#123;[0][0]= 1.0, [1][1]= 1.0&#125;; row-major order to store element in Cnested for loops for accessing char arraysize of it is actual size *4(4 bytes per char)example: another example: function function prototype function calling function definitionexample: When a one-dimensional array is used a function parameter, the length of the array needs to be specified. Notice: sizeof operator no longer gives the right answer: 必须在数组定义处的函数才能用sizeof! The change to the element of the array within a function is reflected in the corresponding arugment. function prototypeDefinition before calling. Or using prototypesFunction prototypes provides the compiler with a brief glimpse of the function.return-type function-name (parameters); function prototype can be placed within main(), as long as it is declared before usage. (But not recommended)variable name is not a must in function prototyping (dummy name) recursionlike what mentioned in MATLAB pointerPointer: Something that directs, indicates, or points Low level but powerful facility available inC Pointer vs. variable:Variable: area of the memory that has been given a namePointer: variable that stores the address of another variable declarationDefining a pointer: type * variable;Handling pointers:The address of a variable x is &amp;xThe value stored at address y is *yThe operator “*” is called dereferencing operatorexample: pointers and arrayArray name is also the address of the first element of the array.name == &amp;name[0] returns true!example: Pointer notation and array notation are the same: date[i] is the same as *(date+i) pointer and function we introduced pointer as an arguments.Pointer can also serve as the return value limitation of CNo limit on the number of inputOnly one outputOutput cannot be an array Dynamic memory allocationFunctions to manage memory: Allocate n bytes of memory, and get a pointer on the first chunk: malloc(n) Allocate n blocks of size s each, set the memory to 0, and get a pointer on the first chunk: calloc(n,s)&#x2F;&#x2F; e.g., s-&gt;sizeof(int) Adjust the size of the memory block pointed to by ptr to s bytes, and get a pointer on the first chunk: realloc(ptr,s) Frees the memory space pointed to by ptr: free(ptr)Variable Length Array after C99, Array size can be determined during the runing of a programBut still, malloc and pointer are the fundamental tools to achieve complex data structures character stringsa char array terminated with a null character &#39;\\0&#39;， cannot be changed!!!string.h can be used for a char array strcpy : The function takes two arguments: a destination buffer where the copied string will be stored, and a source string that will be copied. The function copies the entire source string, including the null terminator, into the destination buffer. char* strcpy(char* destination, const char* source); strcat: accepts two pointer variable as parameters(say dest, src) and, appends the string pointed to by src to the end of the string pointed to by dest. char *strcat(char *dest_str, const char *src_str) strcmp: This function takes two strings (array of characters) as arguments, compares these two strings lexicographically, and then returns 0,1, or -1 as the result. strcmp(_first_str_, _second_str_ ); structStructures: better way to represent data with hidden relationship accessing field Naming a structure for reusabilitywrong def: good example: pointer to a structWhy we need pointers to the struct? Easier to manipulate Passing as input argument Complex data structures adding malloc Advanced Pointer &amp; file IOadvanced use of pointertelling the functions about the structures: just pass over the address of the function save more space than either passing structure members or structures!example: linked listwhy linked list instead of the arrayArray supports random access but insertion and deletion takes more time. Array are of fixed size. implementationdeclaration initializationstruct node *first = NULL; node creation Assigning memory to the node Storing value into the field; Inserting node into a list insert at the beginning search deletion double pointersarrays of stringscharJICSProfs[][11]=&#123;&quot;YifeiZhu&quot;,&quot;PaulWeng&quot;,&quot;YutongBan&quot;,&quot;Yibo Pi&quot;&#125;; its principle: double pointersA pointer to a pointer is a form of multiple indirection. A pointer that is a pointer to a pointer must be defined by introducing additional asterisk in front of its name.The basis of 2D arrays!example: If we want to manipulate or dereference to any of its levels, we have to use Asterisk ( * ) operator the number of times down the level we want to go. Why we need double pointers main function parameter used as function arguments to manipulate the address stored in the local pointer (demo) dynamic memory allocation of multidimensional arrays used in data structures to directly manipulate the address of the nodes without copying.example: OPTIMIZATION for add_to_list:Suppose we want to assign new_node to list, instead of returning new_node algs (Algorithms)Most common types of algorithms: Brute force: often obvious, rarely best Greedy: most common used heuristic Divide and conquer: often recursive Dynamic programming: memorization Search and enumeration: model problem using a graph Randomized algorithms: feature random choices Complexity reduction: rewrite a problem into an easier one complexitytime&amp;space complexity time complexityApproximate description of the relationship between running time and problem size searchlinear searchas mentioned as the name Binary searchexample: sortingselection sort Sorts an array by repeately finding the smallest element Maintain a sorted array Maintain an unsorted oneexample: merge sort(O(n^2))![[Pasted image 20240711212642.png]] I&#x2F;Ostandard I&#x2F;Ostreama a abstract, high-level concept representing a communication channel to a file, device, or process single character I&#x2F;Ogetchar() and putchar()the end of the file:#define EOF -1 in stdio.h file I&#x2F;OopenFILE *fopen(const char *path, const char *mode) mode: one of the r, r+, w, w+, a, a+ NULL: error closeint fclose(FILE *fp) return 0 as success stream standard output: FILE *stdout standard input FILE * stdin standard error output: FILE * stderr reading &amp; writing writing: int fprintf(FILE *stream, const char *format, ...); reading: int scanf(FILE *stream, const char *format, ...); read size - 1 characters: char _fgets(char *s, int size, FILE *stream) write characters to a stream: char *fputs(char *s, FILE *stream) other head filesstring.h length: strlen(const char *s) copy a string: char *strcpy(char *dest, const char *src) Copy at most n bytes of src: char *strncpy(char *dest, const char *src, size_t n) Compare two strings: int strcmp(const char *s1, const char *s2) return value is &lt; 0 0 &gt; 0, if s1 &lt; s2 s1 = s2 s1 &gt; s2 Compare the first n bytes of two strings: int strncmp(const char *s1, const char *s2, size_t n); Locate a character is a string: &#96;char *strchr(const char *s, int c); time.hGetting time:time_t time(time_t *t); calculating the time difference: double difftime(time_t time1, time_t time0); ctype.hvarious types of C:![[Pasted image 20240718165252.png]] math.h![[Pasted image 20240718165316.png]] stdlib.h![[Pasted image 20240718165337.png]] getopt()getopt(int argc, char * const argv[], const char *optstring)：解析命令行参数。 argc 表示参数个数 argv 表示参数列表 optstring 表示选项字符串，选项字符串中的字母表示选项，冒号表示选项后面需要参数（必填）,两个冒号表示选项后面参数选填。返回值为当前选项字母，如果没有选项了则返回 -1。 在本例中，选项字符串为 hvs:E:b:t:，表示有 5 个选项，其中 s、E、b、t 后面需要参数。h、v 后面不需要参数。 关于 optarg，可以理解为是用来保存选项的参数的，而且虽然你没有定义它，但是因为你引入了 getopt.h 头文件，所以它是一个外部变量，你可以直接使用它。 本次测评不要求 h 和 v 选项，所以你也可以用 s:E:b:t: 作为选项字符串（当然后面的逻辑也要对应修改）。 "},{"title":"matlab-intro","date":"2024-05-10T07:06:24.000Z","url":"/2024/05/10/VG101/matlab-intro/","tags":[["Basic","/tags/Basic/"],["matlab","/tags/matlab/"]],"categories":[["Engineering 101","/categories/Engineering-101/"]],"content":"basics: numberbinary systems, difference between MB and Mb, GB, TB, ASCII, unicode… (stupid definitions)how to represent the signed format?8 bits: 1 for sign and 7 for numbersTwo’s complement: invert all the bits of a, add 1 to get −ae.g. :00101010 → 11010101 + 1 &#x3D; 1101011000101010 &#x3D; 0 · 2 7 + 2 5 + 2 3 + 2 &#x3D; 4211010110 &#x3D; −1 · 2 7 + 2 6 + 2 4 + 2 2 + 2 &#x3D; 86 − 128 &#x3D; −42 Data Type for MatlabIn this section, we will learn some basic data types in computer and their conversion in MATLAB. 1. Numeric Types There are two basic types of data, numeric and characters&#x2F;strings. type name definition double Double-precision arrays single Single-precision arrays int8 8-bit signed integer arrays int16 16-bit signed integer arrays int32 32-bit signed integer arrays int64 64-bit signed integer arrays uint8 8-bit unsigned integer arrays … … 2. Simple ConversionConversion between numeric: 3. String&#x2F;Character Types type name definition string string arrays char Character arrays strings String arrays with no characters Compare the following two cases: calculationnumeric calculatorAddition: +Subtraction: -Multiplication: *Power:^Right division: &#x2F;Left division: π: pisqrt(-1): i or jinfinity: Inf other operatorschar operator: ischarString calculator: + basic matlab grammarinput&amp;output arraysinitialzationArray initialization: manualorviafunction Colon operator: initial : step: end operationbasic arithmetic: addition M + 2, subtraction, multiplicationImpose other function sin(M)array operation element-wise: Add a “.” in front of each operation, e.g. .* , like A .* B matrice-wise: Conjugate transpose: ’ Inverse: inv reshape: reshape(A, newsize) reshape the size of A to newsize sum: sum(A) sum up all the elements in A det(A): calculate the determinant eig(A): calculate the eigenvalue and eigenvector matrix Given a matrix, elements can be accessed by: Coordinates: use the (row,column) position A(1, 2) Indices: Use a single number representing a position A(2) The top left element has index 1 (column-first indexing) The bottom right: “number of elements” partial indexing: colon operator Advanced data type: cell arrayAcell array is a composite data type that groups related data using data containers called cells. Each cell can contain any type of data. logic operatornormal operator Operator Description &amp;&amp; Short circuit logical AND || Short circuit logical OR &amp; Bitwise logical AND | Bitwise logical OR example: order of precedence:![[Pasted image 20240530100251.png]] if statement example: if-else statement switch-case-end statement exception handling machanism for loop while loop example: break and continue: the same as C++ vectorizationthe process of revising loop-based, scalar-oriented code to use MATLAB matrix and vector operations.example: vectorization: In Matlab, order of preference: vectorization, for, and while functionsub-function A main function has the same name as the filename A main function is the only function that can be called outside Sub-functions: only accessible by functions from the same file Sub-functions are often used to implement ‘utility‘ calculations for a main function definition pass-by-value schemeMATLAB makes a copy of the actual parameter and passes them to the function. other common functionsfile SLbasic ones save varibles: save(’filename’,’var1’,’var2’,...,’format’) into filename.mat load varibles: load(&#39;file&#39;, &#39;format&#39;) high-level file IOsupporting format: matlab formatted data .mat text .csv, .txt, etc. spreadsheet .xls, etc. image .bmp, .png, etc. audio, video, etc.A&#x3D;importdata(filename) random number generation A nxm matrix of random numbers: rand(n,m) A nxn matrix of random integers between m and M: randi([m M],n) A random permutation of the integers 1:N: randperm(n) Random number generator: Syntax: rng(seed,generator); Random numbers are generated by deterministic algorithm Seed controls the repeatability of your results rng(’shuffle’) seeds the random number generator based on the current time sprintfwriting formatted data into the stringsprintf(’format’,variable1, variable2,...)’formatspec’: text composed of Words,spaces,numbers “%flags”,replaced by the value of variables,e.g.’%d’,’%f’ Special characters, e.g’\\n\\t’ recursionthe process of repeating items in a self-similar way Good about Recursion Recursion:usually leads to compact and elegant codeBad about Recursion: Infinite recursion if no base case identified No guarantee of convergence if not a smaller problem Excessive memory requirements excessive recomputationSo, recursion+memorization! data types![[Pasted image 20240530112114.png]] int: int8, int16, int32 and int64 uint: unit8, uint16, uint32 and uint64 floating point: mantissa and exponent type-related functionType of a varible: whos, isreal, isinf, isnumeric, isnan, isfiniteNumeric conversions: cast(a, ‘type’), uint8(a)useful string functions: isletter, strncmpi(s1, s2, n), isspace, strrep(s1, s2, s3), strcmp(s1, s2), strfind(s1, s2),strcmpi(s1,s2), num2str(a,’format’), strncmp(s1,s2,n), str2num(s)![[Pasted image 20240530112604.png]] structStruct has fields, not elementsAccess its fields by fieldName, not by indexFields in the same struct can have different typesexample: "},{"title":"线性代数八大常见类型的行列式及其解法","date":"2024-04-26T12:21:29.000Z","url":"/2024/04/26/%E5%85%AB%E5%A4%A7%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E8%A7%A3%E6%B3%95/","tags":[["Math","/tags/Math/"],["Linear Algebra","/tags/Linear-Algebra/"]],"categories":[["Linear Algebra","/categories/Linear-Algebra/"]],"content":"cited from 八大类型行列式及其解法 - 知乎 (zhihu.com) 本文记录了八大常见类型的行列式及其解法，解法从一般性到特殊性都有，分享给大家，例子都特别经典好用，希望对线代、高代初学者以及考研党有用。 类型总览： 箭型行列式 两三角型行列式 两条线型行列式 范德蒙德型行列式 $$Hessenberg$$型行列式 三对角型行列式 各行元素和相等型行列式 相邻两行对应元素相差K倍型行列式 方法总览： 拆行法 升阶法 方程组法 累加消点法 累加法 递推法（特征方程法） 步步差法 一：箭型行列式最常见最常用的行列式，特征很好辨识，必须掌握，请看下例： $$eg:D_n&#x3D; \\left|\\begin{array}{cccc} x_1&amp;1&amp;1 &amp;… &amp;1\\ 1&amp;x_2&amp;&amp;&amp;\\ 1&amp;&amp;x_3\\ …&amp;&amp;&amp;…\\ 1&amp;&amp;&amp;…&amp;x_n \\end{array}\\right|(空白处都为0)$$ $$Solution$$: 将第一列元素依次减去第$$ i$$ 列的$$\\frac{1}{x_i},i&#x3D;2…n $$ 得： $$D_n&#x3D; \\left|\\begin{array}{cccc} x_1-\\frac{1}{x_2}-…-\\frac{1}{x_n}&amp;1&amp;1 &amp;… &amp;1\\ 0&amp;x_2&amp;&amp;&amp;\\ 0&amp;&amp;x_3\\ …&amp;&amp;&amp;…\\ 0&amp;&amp;&amp;…&amp;x_n \\end{array}\\right|$$ 所以： $$D_n&#x3D;\\prod_{i&#x3D;2}^{n}x_i(x_1-\\sum_{i&#x3D;2}^{n}\\frac{1}{x_i})$$ 二：两三角型行列式 特征为对角线上方元素均为$$a$$ ,下方元素均为$$b$$ 当 $$a&#x3D;b$$ 时可化为箭型行列式计算，当 $$a\\not&#x3D;b$$ 时采用拆行法计算，请看下面两例 $$eg1(a&#x3D;b):D_n&#x3D;\\left|\\begin{array}{cccc} x_1&amp;b&amp;b &amp;… &amp;b\\ b&amp;x_2&amp;b&amp;…&amp;b\\ b&amp;b&amp;x_3&amp;…&amp;b\\ …&amp;…&amp;…&amp;…&amp;…\\ b&amp;b&amp;b&amp;…&amp;x_n \\end{array}\\right|$$ $$Solution$$: 将第$$i，i&#x3D;2…n$$ 行都减去第一行 得：$$D_n&#x3D;\\left|\\begin{array}{cccc} x_1&amp;b&amp;b &amp;… &amp;b\\ b-x_1&amp;x_2-b&amp;0&amp;…&amp;0\\ b-x_1&amp;0&amp;x_3-b&amp;…&amp;0\\ …&amp;…&amp;…&amp;…&amp;…\\ b-x_1&amp;0&amp;0&amp;…&amp;x_n-b \\end{array}\\right|$$ 即化成了箭型行列式，所以： $$D_n&#x3D;[\\prod_{i&#x3D;2}^{n}(x_i-b)]\\times[x_1-b(b-x_1)\\sum_{i&#x3D;2}^{n}\\frac{1}{x_i-b}]$$ $$eg2(a\\not&#x3D;b):D_n&#x3D;\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;… &amp;a\\ b&amp;x_2&amp;a&amp;…&amp;a\\ b&amp;b&amp;x_3&amp;…&amp;a\\ …&amp;…&amp;…&amp;…&amp;…\\ b&amp;b&amp;b&amp;…&amp;x_n \\end{array}\\right|$$ $$Solution$$: 采用拆行法，目的是为了降阶 $$D_n&#x3D;\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;… &amp;a+0\\ b&amp;x_2&amp;a&amp;…&amp;a+0\\ b&amp;b&amp;x_3&amp;…&amp;a+0\\ …&amp;…&amp;…&amp;…&amp;…\\ b&amp;b&amp;b&amp;…&amp;x_n+b-b \\end{array}\\right|$$ $$D_n&#x3D;\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;… &amp;a\\ b&amp;x_2&amp;a&amp;…&amp;a\\ b&amp;b&amp;x_3&amp;…&amp;a\\ …&amp;…&amp;…&amp;…&amp;…\\ b&amp;b&amp;b&amp;…&amp;b \\end{array}\\right|_{(*)}+\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;… &amp;0\\ b&amp;x_2&amp;a&amp;…&amp;0\\ b&amp;b&amp;x_3&amp;…&amp;0\\ …&amp;…&amp;…&amp;…&amp;…\\ b&amp;b&amp;b&amp;…&amp;x_n-b \\end{array}\\right|$$ 将第 $$i,i&#x3D;1…n-1$$ 列都减去最后一列，得： $$D_n&#x3D;\\left|\\begin{array}{cccc} x_1-a&amp;0&amp;0 &amp;… &amp;a\\ b-a&amp;x_2-a&amp;0&amp;…&amp;a\\ b-a&amp;b-a&amp;x_3-a&amp;…&amp;a\\ …&amp;…&amp;…&amp;…&amp;…\\ 0&amp;0&amp;0&amp;…&amp;b \\end{array}\\right|+(x_n-b)D_{n-1}$$ 所以：$$D_n&#x3D;b\\prod_{i&#x3D;1}^{n-1}(x_i-a)+(x_n-b)D_{n-1}$$ 再由行列式转置不变性得到： $$D_n&#x3D;a\\prod_{i&#x3D;1}^{n-1}(x_i-b)+(x_n-a)D_{n-1}$$ 联立$$(11)(12)$$ ,得通式： $$D_n&#x3D;\\frac{1}{a-b}[a\\prod_{i&#x3D;1}^{n}(x_i-b)-b\\prod_{j&#x3D;1}^{n}(x_j-a)]$$ 通过适当变换可以化为两三角型行列式的，描述不如大家自己看例子揣摩，也很容易理解的，请看下例 $$eg3:D_n&#x3D;\\left|\\begin{array}{cccc} d&amp;b&amp;b &amp;… &amp;b\\ c&amp;x&amp;a&amp;…&amp;a\\ c&amp;a&amp;x&amp;…&amp;a\\ …&amp;…&amp;…&amp;…&amp;…\\ c&amp;a&amp;a&amp;…&amp;x \\end{array}\\right|$$ $$Solution$$: 将第一行乘上 $$\\frac{a}{b}$$ ，第一列乘上 $$\\frac{a}{c}$$ ，得： $$D_n&#x3D;\\frac{bc}{a^2}\\left|\\begin{array}{cccc} \\frac{a^2d}{bc}&amp;a&amp;a &amp;… &amp;a\\ a&amp;x&amp;a&amp;…&amp;a\\ a&amp;a&amp;x&amp;…&amp;a\\ …&amp;…&amp;…&amp;…&amp;…\\ a&amp;a&amp;a&amp;…&amp;x \\end{array}\\right|$$ 即化成了两三角型行列式 一些每行上有公因子但是无法向上式那样在保持行列式不变得基础上能提出公因子的，采用升阶法，请看下例 $$eg4:D_n&#x3D;\\left|\\begin{array}{cccc} 1+x_{1}^2&amp;x_1x_2&amp;x_1x_3 &amp;… &amp;x_1x_n\\ x_2x_1&amp;1+x_{2}^2&amp;x_2x_3&amp;…&amp;x_2x_n\\ x_3x_1&amp;x_3x_2&amp;1+x_{3}^2&amp;…&amp;x_3x_n\\ …&amp;…&amp;…&amp;…&amp;…\\ x_nx_1&amp;x_nx_2&amp;x_nx_3&amp;…&amp;1+x_{n}^2 \\end{array}\\right|$$ $$Solution$$: 加边升阶，得： $$D_n&#x3D;\\left|\\begin{array}{cccc} 1&amp;x_1&amp;x_2&amp;x_3&amp;…&amp;x_n\\ 0&amp;1+x_{1}^2&amp;x_1x_2&amp;x_1x_3 &amp;… &amp;x_1x_n\\ 0&amp;x_2x_1&amp;1+x_{2}^2&amp;x_2x_3&amp;…&amp;x_2x_n\\ 0&amp;x_3x_1&amp;x_3x_2&amp;1+x_{3}^2&amp;…&amp;x_3x_n\\ 0&amp;…&amp;…&amp;…&amp;…&amp;…\\ 0&amp;x_nx_1&amp;x_nx_2&amp;x_nx_3&amp;…&amp;1+x_{n}^2 \\end{array}\\right|$$ 再将第 $$i,i&#x3D;2…n+1$$ 都减去第一行的$$x_i，i&#x3D;1…n$$ 倍，得： $$D_n&#x3D;\\left|\\begin{array}{cccc} 1&amp;x_1&amp;x_2&amp;x_3&amp;…&amp;x_n\\ -x_1&amp;1&amp;0&amp;0 &amp;… &amp;0\\ -x_2&amp;0&amp;1&amp;0&amp;…&amp;0\\ -x_3&amp;0&amp;0&amp;1&amp;…&amp;0\\ 0&amp;…&amp;…&amp;…&amp;…&amp;…\\ -x_n&amp;0&amp;0&amp;0&amp;…&amp;1 \\end{array}\\right|$$ 即又化成了箭型行列式，可得通式： $$D_n&#x3D;1+\\sum_{i&#x3D;1}^{n}x_{i}^{2}$$ 三：两条线型行列式特征是除了主(次)对角线或与其相邻得一条斜线所组成的任意一条线加四个顶点中的某个顶点外，其他元素均为$$0$$，这类行列式可以直接展开降阶。这段描述有点繁琐，但其实也并不复杂，请看下例理解 $$eg3:D_n&#x3D;\\left|\\begin{array}{cccc} a_1&amp;b_1&amp; &amp;… &amp;\\ &amp;a_2&amp;b_2&amp;…&amp;\\ &amp;&amp;a_3&amp;…&amp;\\ &amp;&amp;&amp;\\ &amp;&amp;…&amp;a_{n-1}&amp;b_{n-1} \\ b_n&amp;&amp;…&amp;&amp;a_n \\end{array}\\right| (空白处都为0)$$ $$Solution$$: 按照第一列两个非$$0$$元素拉普拉斯展开即可 $$D_n&#x3D;\\prod_{i&#x3D;1}^{n}a_i+(-1)^{n+1}\\prod_{i&#x3D;1}^{n}b_i$$ 四：范德蒙德型行列式范德蒙德行列式大家应该熟悉，而范德蒙德型行列式的特征就是有逐行(列)元素按幂递增(减)，可以将其转化为范德蒙德行列式来计算，请看下例 $$eg:D_n&#x3D;\\left|\\begin{array}{cccc} a_{1}^n&amp; a_{1}^{n-1}b_1&amp;… &amp;a_1b_1^{n-1}&amp;b_1^n\\ a_{2}^n&amp;a_{2}^{n-1}b_2&amp;…&amp;a_2b_2^{n-1}&amp;b_2^n\\ …&amp;…&amp;…&amp;…&amp;…\\ a_{n}^n&amp;a_{n}^{n-1}b_n&amp;…&amp;a_nb_n^{n-1}&amp;b_n^n\\ a_{n+1}^n&amp;a_{n+1}^{n-1}b_{n+1}&amp;…&amp;a_{n+1}b_{n+1}^{n-1}&amp;b_{n+1}^n \\end{array}\\right|$$ $$Solution$$: 将每行都提出 $$a_i^{n},i&#x3D;1…n+1 $$倍，得： $$D_n&#x3D;\\prod_{i&#x3D;1}^{n+1}a_i^n\\left|\\begin{array}{cccc} 1&amp; \\frac{b_1}{a_1}&amp;… &amp;(\\frac{b_1}{a_1})^{n-1}&amp;(\\frac{b_1}{a_1})^{n}\\ 1&amp;\\frac{b_2}{a_2}&amp;…&amp;(\\frac{b_2}{a_2})^{n-1}&amp;(\\frac{b_2}{a_2})^{n}\\ …&amp;…&amp;…&amp;…&amp;…\\ 1&amp;\\frac{b_n}{a_n}&amp;…&amp;(\\frac{b_n}{a_n})^{n-1}&amp;(\\frac{b_n}{a_n})^{n}\\ 1&amp;\\frac{b_{n+1}}{a_{n+1}}&amp;…&amp;(\\frac{b_{n+1}}{a_{n+1}})^{n-1}&amp;(\\frac{b_{n+1}}{a_{n+1}})^{n} \\end{array}\\right|$$ 上式即为范德蒙德行列式，所以通式为： $$D_n&#x3D;\\prod_{1\\le i&lt;j\\le n+1}(a_ib_j-b_ia_j)$$ 五：$$Hessenberg$$型行列式特征为除了主(次)对角线及与其相邻的斜线，再加上第一行(列)或第$$n$$行(列)外，其余元素均为$$0$$。这类行列式有点像前面说的两条线型行列式，但是还是有一点区别的。这类行列式都用累加消点法，即通常将某一行(列)都化简到只有一个非$$0$$元素，以便于降阶计算，请看下例 $$eg:D_n&#x3D; \\left|\\begin{array}{cccc} 1&amp;2&amp;3 &amp;… &amp;n-1&amp;n\\ 1&amp;-1&amp;&amp;&amp;&amp;\\ &amp;2&amp;-2&amp;…\\ …&amp;…&amp;…&amp;…&amp;…&amp;…\\ &amp;&amp;&amp;n-2&amp;2-n&amp;\\ &amp;&amp;&amp;…&amp;n-1&amp;1-n \\end{array}\\right|$$ $$Solution$$: 将各列都加到第一列，得到： $$D_n&#x3D; \\left|\\begin{array}{cccc} \\frac{n(n+1)}{2}&amp;2&amp;3 &amp;… &amp;n-1&amp;n\\ 0&amp;-1&amp;&amp;&amp;&amp;\\ 0&amp;2&amp;-2&amp;…\\ …&amp;…&amp;…&amp;…&amp;…&amp;…\\ 0&amp;&amp;&amp;n-2&amp;2-n&amp;\\ 0&amp;&amp;&amp;…&amp;n-1&amp;1-n \\end{array}\\right|$$ 降阶之后再重复上述步骤即可得到通式： $$D_n&#x3D;(-1)^{n-1}\\frac{(n+1)!}{2}$$ 注：需要说明的是，上面举的例子比较容易看出如何实施累加消点法就可以实现将某一行(列)都化简到只有一个非$$0$$元素从而达到降阶的目的，但是还有很多$$Hessenberg$$型行列式并不这么容易就做到，还需要大家找找技巧稍微变换一下，只要始终记得你要用累加消点法来消元来降阶就可以了 六：三对角型行列式这是一种递推结构的行列式，特征为所有主子式都有相同的结构，从而以最后一列展开，将所得的$$(n-1)$$ 阶行列式再展开即得递推公式，即**递推法(特征方程法)**，请看下例 $$eg:D_n&#x3D; \\left|\\begin{array}{cccc} a&amp;b&amp; &amp;&amp;… &amp;&amp;&amp;\\ c&amp;a&amp;b&amp;&amp;…&amp;&amp;&amp;\\ &amp;c&amp;a&amp;b&amp;…&amp;&amp;\\ …&amp;…&amp;…&amp;…&amp;…&amp;\\ &amp;&amp;&amp;&amp;…&amp;a&amp;b\\ &amp;&amp;&amp;&amp;…&amp;c&amp;a \\end{array}\\right|$$ $$Solution$$: 按第一列拉普拉斯展开，得： $$D_n&#x3D;aD_{n-1}-bcD_{n-2}$$ 解特征方程： $$x^2&#x3D;ax-bc$$ ，得： $$x_1&#x3D;\\frac{a+\\sqrt{a^2-4bc}}{2}$$ $$x_2&#x3D;\\frac{a-\\sqrt{a^2-4bc}}{2}$$ 即可得通式： $$D_n &#x3D; \\frac{x_1^{n+1}-x_2^{n+1}}{x_1-x_2}$$ 注：特征方程法我没记错的话，应该是在高中将数列的时候用到的。 七：各行元素和相等型行列式这个特征已经很清楚了吧，方法就是累加法，很简单，直接看下例 $$eg:D_n&#x3D; \\left|\\begin{array}{cccc} 1+x_1&amp;x_1 &amp;… &amp;x_1\\ x_2&amp;1+x_2&amp;…&amp;x_2\\ …&amp;…&amp;…&amp;…\\ x_n&amp;x_n&amp;…&amp;1+x_n \\end{array}\\right|$$ $$Solution$$: 将第$$i,i&#x3D;2…n$$ 行都加到第一行去，得： $$D_n&#x3D; \\left|\\begin{array}{cccc} 1+\\sum_{i&#x3D;1}^{n}x_i&amp;1+\\sum_{i&#x3D;1}^{n}x_i &amp;… &amp;1+\\sum_{i&#x3D;1}^{n}x_i\\ x_2&amp;1+x_2&amp;…&amp;x_2\\ …&amp;…&amp;…&amp;…\\ x_n&amp;x_n&amp;…&amp;1+x_n \\end{array}\\right|$$ 所以： $$D_n&#x3D; (1+\\sum_{i&#x3D;1}^{n}x_i)\\left|\\begin{array}{cccc} 1&amp;1 &amp;… &amp;1\\ x_2&amp;1+x_2&amp;…&amp;x_2\\ …&amp;…&amp;…&amp;…\\ x_n&amp;x_n&amp;…&amp;1+x_n \\end{array}\\right|&#x3D; (1+\\sum_{i&#x3D;1}^{n}x_i)\\left|\\begin{array}{cccc} 1&amp;0&amp;… &amp;0\\ x_2&amp;1&amp;…&amp;0\\ …&amp;…&amp;…&amp;…\\ x_n&amp;0&amp;…&amp;1 \\end{array}\\right|&#x3D;1+\\sum_{i&#x3D;1}^{n}x_i$$ 八：相邻两行对应元素相差K倍型行列式这个要用步步差法 (1)大部分元素为数字，且相邻两行对应元素相差为$$1$$，采用逐步作差的方法，即可出现大量 $$\\pm1$$ 元素，进而出现大量$$0$$元素 (2)若相邻两行相差$$K$$倍，采用逐步作$$k$$倍差得方法，即可出现大量$$0$$元素 请看下面两个例子 $$eg1:D_n&#x3D; \\left|\\begin{array}{cccc} 0&amp;1&amp;2 &amp;…&amp;n-2 &amp;n-1\\ 1&amp;0&amp;1&amp;…&amp;n-3&amp;n-2\\ 2&amp;1&amp;0&amp;…&amp;n-4&amp;n-3\\ …&amp;…&amp;…&amp;…&amp;…&amp;…\\ n-2&amp;n-3&amp;n-4&amp;…&amp;0&amp;1\\ n-1&amp;n-2&amp;n-3&amp;…&amp;1&amp;0 \\end{array}\\right|$$ $$Solution$$: 从第一行开始，依次用前一行减去后一行，得： $$D_n&#x3D; \\left|\\begin{array}{cccc} -1&amp;1&amp;1 &amp;…&amp;1 &amp;1\\ -1&amp;-1&amp;1&amp;…&amp;1&amp;1\\ -1&amp;-1&amp;-1&amp;…&amp;1&amp;1\\ …&amp;…&amp;…&amp;…&amp;…&amp;…\\ -1&amp;-1&amp;-1&amp;…&amp;-1&amp;1\\ n-1&amp;n-2&amp;n-3&amp;…&amp;1&amp;0 \\end{array}\\right|$$ 再将第一列加到第$$i,i&#x3D;2…n$$ 列，得： $$D_n&#x3D; \\left|\\begin{array}{cccc} -1&amp;0&amp;0&amp;…&amp;0&amp;0\\ -1&amp;-2&amp;0&amp;…&amp;0&amp;0\\ -1&amp;-2&amp;-2&amp;…&amp;0&amp;0\\ …&amp;…&amp;…&amp;…&amp;…&amp;…\\ -1&amp;-2&amp;-2&amp;…&amp;-2&amp;0\\ n-1&amp;2n-3&amp;2n-4&amp;…&amp;n&amp;n-1 \\end{array}\\right|&#x3D;(-1)^{n-1}(-2)^{n-2}(n-1)$$ $$eg2:D_n&#x3D; \\left|\\begin{array}{cccc} 1&amp;a&amp;a^2 &amp;…&amp;a^{n-2} &amp;a^{n-1}\\ a^{n-1}&amp;1&amp;a&amp;…&amp;a^{n-3} &amp;a^{n-2} \\ a^{n-2} &amp;a^{n-1} &amp;1&amp;…&amp;a^{n-4} &amp;a^{n-3} \\ …&amp;…&amp;…&amp;…&amp;…&amp;…\\ a^2&amp;a^3&amp;a^4&amp;…&amp;1&amp;a\\ a&amp;a^2&amp;a^3&amp;…&amp;a^{n-1}&amp;1 \\end{array}\\right|$$ $$Solution$$: 从第一行开始，依次用前一行加上后一行的$$(-a)$$ 倍，得： $$D_n&#x3D; \\left|\\begin{array}{cccc} 1-a^n&amp;0&amp;0&amp;…&amp;0&amp;0\\ a^{n-1}&amp;1-a^n&amp;0&amp;…&amp;0 &amp;0\\ 0 &amp;0 &amp;1-a^n&amp;…&amp;0&amp;0 \\ …&amp;…&amp;…&amp;…&amp;…&amp;…\\ 0&amp;0&amp;0&amp;…&amp;1-a^n&amp;0\\ a&amp;a^2&amp;a^3&amp;…&amp;a^{n-1}&amp;1 \\end{array}\\right|$$ 所以： $$D_n&#x3D;(1-a^n)^{n-1}$$"},{"title":"61B part 5..4 Graph","date":"2024-04-26T12:01:29.000Z","url":"/2024/04/26/61B/61B-P5-4-Graph/","tags":[["Java","/tags/Java/"],["61B","/tags/61B/"],["Graph","/tags/Graph/"],["Shortest_path","/tags/Shortest-path/"],["MST","/tags/MST/"]],"categories":[["CS 61B","/categories/CS-61B/"]],"content":"Trees A set of connected nodes (or vertices). We use both terms interchangeably. A set of edges that connect those nodes. No edges can form a cycle. Constraint: There is exactly one path between any two nodes.function: speeding up searching for items Tree Traversalwhat are some natural ways to ‘traverse’ (iterate) through a tree? Level order traversal. Breadth First Search (BFS) Depth-First traversals –– of which there are three: pre-order, in-order and post-order. (DFS) pre-order in-orderinstead of visiting (aka printing) first, we’ll first visit the left branch. Then we’ll print. Then we’ll visit the right branch. post-order GraphsdefinitionA graph consists of: A set of nodes (or vertices) A set of zero of more edges, each of which connects two nodes.note that all trees are also graphs, but not all graphs are trees. simple graphs &amp; multigraphsSimple graphs: do not have loops &amp; multiple ways from one to another more categories problems s-t Path: Is there a path between vertices s and t? Connectivity: Is the graph connected, i.e. is there a path between all vertices? Biconnectivity: Is there a vertex whose removal disconnects the graph? Shortest s-t Path: What is the shortest path between vertices s and t? Cycle Detection: Does the graph contain any cycles? Euler Tour: Is there a cycle that uses every edge exactly once? Hamilton Tour: Is there a cycle that uses every vertex exactly once? Planarity: Can you draw the graph on paper with no crossing edges? Isomorphism: Are two graphs isomorphic (the same graph in disguise)? &#x2F;&#x2F; a million-dollar problem!…let’s solve the first problem: if s and t connected? triversalBFS fringe: the data structure we are using to store the nodes on the frontier of our traversal’s discovery processedgeTo[...]: a map that helps us track how we got to node n; we got to it by following the edge from v to to n.distTo[...]: helps us track how far n is from the starting vertex DFS graphs API we want to get quick answers to these questions: Are given vertices u and v adjacent? Is vertex v incident to a particular edge e? What vertices are adjacent to v? What edges are incident to v?so we use adjacency list for the data structure. Adjacency List![[Pasted image 20240514103306.png]]An array is created with each vertice in graph, each of them points to a list that including all of the edges of the vertice Shortest pathBFS or DFS will never have the ability to get the shortest path in the least time always, so some algs are developed. Dijkstra’s AlgorithmYou are on campus and playing a game with your friends around Hearst Memorial Mining Building. You start at the location s and you want to go to the location t.![[Pasted image 20240514110735.png]]BFS will yield a route of length 330m.![[Pasted image 20240514110800.png]]Goal: minimize the sum of the weights of the edges on the selected path.the shortest paths tree from a source s can be created in the following way: For every vertex v (which is not s) in the graph, find the shortest path from s to v. “Combine”&#x2F;“Union” all the edges that you found above.the “Shortest Path Tree” will always be a tree. Why? For every node, there was exactly one “parent” in the edgeToedgeTo array that we have maintained in our original solution. workingHow does it work? Create a priority queue. Add s to the priority queue with priority 00. Add all other vertices to the priority queue with priority ∞∞. While the priority queue is not empty: pop a vertex out of the priority queue, and relax all of the edges going out from the vertex. relaxvertex: vLook at your current best distance to w from the source, call it curBestDistToW. Now, look at your curBestDistToV+weight(v,w) (let’s call it potentialDistToWUsing).Is potentialDistToWUsing better, i.e., smaller than curBestDistToW? In that case, set curBestDistToW&#x3D;potentialDistToWUsingV, and update the edgeToW to be v implementation disadvantages![[Pasted image 20240514113547.png]]Suppose you’re at that vertex labeled 34. Now you’re going to try to relax all your edges. You have only one outgoing edge from yourself to 33 with weight −67. Ah, but note: vertex 33 is already visited (it’s marked with white.) So… we don’t relax it. (Recall the pseudocode for the relax method.)Now we go home thinking that the shortest distance to 33 is 82 (marked in pink.) But really, we should have taken the path through 34 because that would have given us a distance of 101−67&#x3D;34.Dijkstra’s algorithm is not guaranteed to be correct for negative edges. It might work… but it isn’t guaranteed to work. short-circuitif a vertice is popped out from the queue, the algs is stopped (short-circuited). A* algslet’s consider the drawbacks of Dijkstra’s algorithm: if you want to seek a road from the middle of the US to the east, you will must have to make a circle first, lowering the effeciency. How can we let computer know that it is better to move towards east then west? The A-star![[Pasted image 20240514221630.png]]f(n)&#x3D;g(n)+h(n)f(n): the priority of node ng(n): the cost of node n from the starth(n): the estimated cost of n to final ones implementation The priority of nodes are usually computed by the specific algs for specific cases. minimum spanning treeshow to find a circle in a graph? spanning treesan undirected graph, a spanning tree T is a subgraph of G, where T : is connected is acyclic (not circled) includes all of the vertices MSTthe spanning trees that its sum of priority is the least ones. cut propertycut: an assignment of a graph’s node to 2 setscorssing edge: an edge which connects the 2 node from 2 different sets![[Pasted image 20240515103058.png]]given any cut, minimum weight crossing edge is in the MST. (can be easily proved.) Prim’s algs Start from one node add shortest edge that has one node inside the MST under construction and repeat the process implementationusing priority heap queues, storing vertices in order of distance from treerepeat(remove closest vertex v from PQ, and relax all edges pointing from v) VS Dijkstra’s algsthe same except: visiting order: Prim’s in order of distance from the MST, while D’s in order of distance from sourcerelaxation: Dijkstra’s considers an edge better based on distance to source Prim’s a dege better based on distance to tree complexityO(ElogV) Kruskal’s algsordering the edges by their priorities, and add the edge from smallest to biggest without circle (using union-find datastructure). implementation"},{"title":"61B part 5.3 Prior Queues&heap","date":"2024-04-26T12:01:08.000Z","url":"/2024/04/26/61B/61B-P5-3-PQ/","tags":[["Java","/tags/Java/"],["61B","/tags/61B/"]],"categories":[["CS 61B","/categories/CS-61B/"]],"content":"Priority Queue interface Task: use the interface to track the M bestcore code: perfect implementation–heap HeapWe will define our binary min-heap as being complete and obeying min-heap property: Min-heap: Every node is less than or equal to both of its children Complete: Missing items only at the bottom level (if any), all nodes are as far left as possible.![[Pasted image 20240427225515.png]]The green ones are correct min-heaps and red ones are not.we can see that as the root is smaller than all its children, it is smaller than anyone in the queue. ImplementationgetSmallest: return the root nodeadd: add the element to the bottom left position exchange it with the upper ones to ensure the charactersremoveSmallest: remove the root, and then move the element on the bottom to the top, then exchanging Tree implementation in Java1. create map from parent to children1.1.![[Pasted image 20240428142605.png]] 1.2.![[Pasted image 20240428142731.png]] 1.3.![[Pasted image 20240428142927.png]] store keys in an array(similar to that in union-find sets)![[Pasted image 20240428143407.png]] store keys in an array. Do not store structuresonly works for complete trees 3.2(book implementation):Store keys in an array. Offset everything by 1 spot. leave spot 0 empty. make computation of parents and kids easier.complexity for each Implementation of PQs:![[Pasted image 20240428151149.png]]memory complexity, code simplexity considered, heap is the easiest one.Summary: search data structures![[Pasted image 20240428152036.png]] "},{"title":"61B part 5.2 hashing","date":"2024-04-21T03:22:24.000Z","url":"/2024/04/21/61B/61B-part5-2-hashing/","tags":[["Java","/tags/Java/"],["61B","/tags/61B/"],["HashMap","/tags/HashMap/"]],"categories":[["CS 61B","/categories/CS-61B/"]],"content":"prev:[[61B-part-5-1-BST]]next: prev: BSTsdisadvantages: comparable: need to be able to ask “X&lt;Y”questions O(logN) can be better extreme approach: using data as the index initial all values as false when an item is added, the index is set to be true.drawback: extreme waste of memorysuppose we want to add “cat”problems: what is the catth element of the list? –use cas the index other words started with c collides with cat, and cannot store words like =equals()…solution: use the “power of 27”$$cat_{27} &#x3D; 327^2+127^1+20*27^0&#x3D;2234_{10}$$the algs will give each lowercase English word a unique number!ASCII Characters: &gt;&#x3D;127进制Chinese characters: &gt;&#x3D;40959进制However, the problem: integer overflowif biggest number in int, it +1 &#x3D; smallest number!the code: Hashcodechallenges: how to handle hashcoode collisions?(collision handling_) how can we compute a hash code for arbitrary objects? (computing a hashCode)solution: instead of storing true in position h, store a “bucket” oif these N items at the position h.The bucket implementation: linked list, arraylist,arrayset… separate chaining data indexed array![[Pasted image 20240421132226.png]] the bucket h is empty –&gt; create a new list containing x, store it at index h.the bucket h is already a list –&gt; add x to this list if it is not already present.we can use the modulus of hashcode to reduce bucket count! (downside: lists will be longer) improvementsuppose: fixed number of buckets M increasing number of Nproblem: even if the items are spread out evenly, the lists are of length Q&#x3D;N&#x2F;M, therefore the complexity is O(N). example strategywhen N&#x2F;M &gt;&#x3D; 1.5, double M(N&#x2F;M: “load factor”) how full the hast tabhle is.Therefore, now we have: increasing number of buckets M increasing number of items NO(N&#x2F;M) &#x3D;O(1) RuntimeOne important thing to consider: resizing operation. resizing takes O(N) time add takes O(1)+ time (O(N) when resizing) contains takes O(1)+ time on average. Ubiquity great performance in practice implementations are simple python dictionary are just hash tables. used in HashMap and HashSet, not implements Hashable (all objects in Java must implement a .hashcode() method) Negative hash codesunfortunately, -1%4&#x3D;-1 will result in index errors.Therefore, use Math.floorMod instead. Warning never store objects that can change in HashSet or HashMap! never override equals without override hashCode! HashCodegoal: make the table bushyjava’s HashCode() for strings: 31-basedIt seemed like that 126 is better. However, the overflow is a bad problem for base 126!major collision problem for base 126: Any string that ends in the same last 32 characters has the same hash code!$$126^{32}&#x3D;126^{33}&#x3D;126^{34}&#x3D;…0$$See 61C for more.Typical hash code: a small prime."},{"title":"61B part 5.1 BSTs, B trees, red black trees","date":"2024-04-20T05:49:21.000Z","url":"/2024/04/20/61B/61B-part-5-1-BST/","tags":[["Java","/tags/Java/"],["61B","/tags/61B/"],["BST","/tags/BST/"],["Tree","/tags/Tree/"],["BTree","/tags/BTree/"],["RBT","/tags/RBT/"]],"categories":[["CS 61B","/categories/CS-61B/"]],"content":"prev:[[start gitlet]]next:[[61B-part5-2-hashing]]disjoint sets: see [[Algs1.5_UnionFind]] Abstract Data Typesit is defined only by its operations, not by its implementation.for example: stack is defined by its operation: push(int x) and int pop(), not by its implementation (Array or LinkedList) CollectionsOne of the most important interfaces in Java.Maps, Lists, Sets are inherianted from it. Mapsexample: the contents: sumomo 1 mo 2 momo 2 no 1 uchi 1 Basic ideas behind the TreeMaps and TreeSets: BST (Binary Search Tree) BSTs (Binary Search Trees)The search in single linked list is very slow in Java.![[LinkedList.png]]To optimize it: Skip list (won’t be discussed): Add (random) express lanes![[SkipList.png]] Move pointer to middle and flip left links. It is faster!![[BST0.png]]How to make it even faster? – think of the recursion!![[BST1.png]]just do the middle search recursively, and then get the result. definitionsTreeconsists of: A set of nodes. A set of edges that connect those nodes. Constraint: There is exactly one path between any two nodes. Binary treea tree that a parent have 0&#x2F;1&#x2F;2 kids BSTOrdering must be complete, transitive, and antisymmetric. Given keys p and q: Exactly one of p ≺ q and q ≺ p are true. p ≺ q and q ≺ r imply p ≺ r. OperationsFindingIf searchKey equals T.key, return. If searchKey ≺ T.key, search T.left. If searchKey ≻ T.key, search T.right. Insert find: do nothing didn’t find: create the key with appropriate link. Never implement like this: DeleteJust remember the ultimate goal: maintain BST ability! B Trees (Balanced search trees)Some basic terms in trees: depth: the number of links between a node and the root. height: the lowest depth of a tree. average depth: average of the total depths in the tree. You calculate this by taking $$∑𝑖&#x3D;0𝐷𝑑𝑖𝑛𝑖𝑁​N​​∑​i&#x3D;0​D​​d​i​​n​i​​​​$$ where d​i​​ is depth and n​i​​ is number of nodes at that depth.The worst case of BSTs are O(N). (exactly the same case as linked lists!)(In most case, the complexity of a algorithm is represented by its worst one.)However, it have been proven that when inserting data randomly, the tree are intended to be grow to the better case (~O(logN)).But in real world, the data didn’t come in a time usually. They always comes in different times. Avoiding imbalanceSo, a crazy idea is that we never add leaves on our bottom!![B- tree] (oi-wiki.org&#x2F;ds&#x2F;images&#x2F;b-tree-1.svg) The Problem: if you end with the idea, multiple linked lists will come again!Solution: set limit to the leaves, and move the elements onto their parents when the limit is reached.![insert 1](23tree-insert3b.png (283×363) (princeton.edu)]())![23tree-split](23tree-split.png (210×436) (princeton.edu)]())But, what if it is no longer a BST when the number have been moved?split it into left and right part!If anyone is longer than the certain limit, the number in the middle left or the center will be push up!we can see that through the operation, the tree have reached perfect balance.B Trees of L&#x3D;3 is also called “2-3-4 trees”To simulate the B Trees, you can look at this websiteWe can garantee that our trees are bushy!Overall height: $$log_(L+1)N-log_2N$$So, the complexity: logN Red-black TreesRotationdisadvantage of the B trees: it is complex to implement tree rotation![[Tree_rotation.png]]rotateLeft(G): let x be the right child of G, and make G the new left child of x.![[Pasted image 20240421103400.png]] required: Self-balance!Rotation can balance the tree while preserving tree property.its code implementation needs one of the nodes are temparily stored. AVL trees (not required)平衡因子&#x3D;右子树高度-左子树高度if (|平衡因子|&gt;1) rotation!insert &amp; delete are similar to BSTs.演示 Red-black treeshow to represent a 2-3 tree as a BST? – rotate! one possible way: conecting nodebut sides are wasted!![[Pasted image 20240421104317.png]] another way: to use a “connected edge”For convenience, the connected edge are signed as red, and others are black.In code implementation, we can represent the color of edge in the child node.![[Pasted image 20240421104718.png]]using the left connected edge as the 2-3 trees are LLRB(left leaning red black tree).search operations are the same as BSTs! properties 和2-3树一一对应！（if the corresponding 2-3 trees are illegal, the LLRB is illegal） no node have 2 red links. every path from root to a leaf have the same number of black links. complexity: O(logN) (if maximum height of the corresponding 2-3 tree is H, the one of LLRB is 2H+1) constructionfirst construct a 2-3 tree, and then modify it into LLRB🤣 first put in like BST. using Rotation to ensure the corresponding relationship (maintaining balance).detailed construction rules: always use red side when inserting. insert it into the right side: LeftRotation produces adjacent red edges after inserting: RightRotation 2 red edges in one node: flip implementation"},{"title":"Prin Algs Part 1 Union-Find","date":"2024-04-13T16:00:00.000Z","url":"/2024/04/14/Algs1.5_UnionFind/","tags":[["Java","/tags/Java/"],["Algs","/tags/Algs/"]],"categories":[["Algs","/categories/Algs/"]],"content":"Union and Finddynamic connectivitygiven a set of N objectsunion: connect 2 objectsfind&#x2F;connected: is there a path connecting the two objects?Today’s problem: is there any paths? (the exact path to find will be discussed later) eager-approach: quick-findInteger array id[] of size N.Interpretation: p and q are connected iff they have the same id.check: check if p and q have the same id.the code: drawbacks: Too slow Union too expansive (Take N^2^ array accesses to process sequences of N union commands on N objects.) (quadratic 二次的 time is too slow) For example: prev: 1000 times per second –&gt; 1000 boxes of memorys now:10^9^ times per second –&gt; 10^9^ boxes of memorys for union-find operations: prev: 10^6^ operations now: 10^18^ operations as the data grow bigger, it is much slower quadratic algorithm –&gt; many times slower when problems goes bigger lazy approach: quick-unionInteger array id[] of size N.id[i] is parent of i.Root of i is id[id[id[…id[i]…]]] (keep going until is doesn’t change)Find: check if the pand q have the same rootUnion: merge components containing p and q. set the id of p‘s root to the id of q‘s root.code: Too slow – the tree can be too tall.Find can be expansive. Improvementweighting keep track of all the trees avoid tall trees to be lower (connect the root of smaller trees to the taller trees)code: running time: Depth of any node x is at most log2N. (for CS, lg &#x3D; log2)acceptable performance: great (when the data bigger, the programs also faster) path compressionJust after computing the root of p, set the id of each examined node to point to that root. Application: Percolation"},{"title":"CS 61B Intro to Gitlet","date":"2024-04-09T13:13:14.000Z","url":"/2024/04/09/61B/start%20gitlet/","tags":[["CS","/tags/CS/"],["61B","/tags/61B/"],["project2","/tags/project2/"]],"categories":[["CS 61B","/categories/CS-61B/"]],"content":"gitlet previewprev: [[Git-intro]]next: number systemdecimal number system 十进制binary number system 二进制hexadecimal number system 十六进制hexadecimal is what you usually see in CS. command line compilationHello.java –&gt; javac –&gt; Hello.class –&gt; java –&gt; runningpublic static void main(String[] args)(String[] args) refer to the command line argumentsGit we are using today are written in C, which is compiled directly into a binary and does’t need the complier. So for c programs, we just call git status instead of java git status. GitWhy version control?maintaining multiple copies is useful for the project. git preview: things haven’t covered Maps. Hashing. File I&#x2F;O. Graphs. How it worksevery time commit, store a copy of the entire repo in a secret folder in your computer, called .git. Naive approach 1: each commit is stored in a subdirectory with copies of each file.Inefficient: several identical files.![[屏幕截图 2024-04-13 173120.png]] approach 2: Store only files that change![[屏幕截图 2024-04-13 173329.png]]Inefficient: To figure out which files to copy, we have to walk through all of the commits to determine which file we gonna use. Appoarch 3: 2 but version data structureEach commit is a “map” or “dictionary”. For each filename, it maps that filename to a version number.Example: V4 in Python might be represented by &#123;“Hello.java”: 2, “Friend.java”: 4, “Egg.java”: 3&#125;Advantage: do not need to think which one to select.However, if the A.java in V5 is the same as that in V1, how to increase efficiency?Hashingexamine the difference between files Another question: if 2 programmers working on the same project: both start at V3 A changes Horse.java and commit B change Fish.java and commit who is V4?Suggest B first, A’ s computer would have no idea that this commit have been made. Approach 4: use time &amp; date as the version numberRather than using an escalating integer version number, we could use the current time and date. Possible concern: Two programmers make commits (or files) at the same time. Approach 5: Use a “Hash” as the Version NumberGit use “git-SHA1 hash” of the file as its version number.Also, git use the git-SHA1 hash to store the data.drawback: maybe the same hash number for some files. (the chance is very low!)A benefit of Hashing: security (detecting hash) Serializablesee in lab6used for enable classes to write&#x2F;read objects from files Branchingmergingfirst: then: Can switch back to the master branch with checkout. Can also attempt to merge branches. if the 2 branches did modification to the same file, then the merge conflict happens, because git didn’t know which file to follow. ![[屏幕截图 2024-04-13 205131.png]]"},{"title":"intro to Git","date":"2024-04-08T13:13:14.000Z","url":"/2024/04/08/61B/Git-intro/","tags":[["Git","/tags/Git/"],["tools","/tags/tools/"],["CS","/tags/CS/"],["61B","/tags/61B/"],["project2","/tags/project2/"]],"categories":[["CS 61B","/categories/CS-61B/"]],"content":"prev: [[part4-Iterators]]next: Intro to GitIntroductionVersion controlV1.0本地版本控制系统 local version control system V0.0复制整个项目目录–&gt; V1.0用某种简单的数据库来记录文件的历次更新差异 Most popular: RCS (在硬盘上保存补丁集) V2.0 不同开发者协同工作需求–集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS） 单一的集中管理的服务器，保存所有文件的修订版本 例子： CVS… 缺点：过于依靠服务器，服务器宕机就寄 V3.0 分布式版本控制系统（Distributed Version Control System，简称 DVCS） 客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 例子：git Git featureSnapshotsThe other version control system are delta-based. However, the git system are snapshot-based. 几乎所有操作都在本地进行 保证数据完整性(Hash表)，一般只添加数据 statuscommited, modified, and staged 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 已提交表示数据已经安全地保存在本地数据库中。These made the Git have three areas.基本的 Git 工作流程如下： 在工作区中修改文件。 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。get some help of Git: Basic Gitinitializea. init b. clone recordingThe status of the file in repo: tracked and untracked.To get the file tracked: git add . or git add READMETo check the status of the file: More simple: git status -s To summarize: ignoring difference查看当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。 查看已暂存的变化： commit先用git status 确认文件都已经暂存，然后提交 如果没有暂存文件，可以用-a命令跳过暂存空间直接commit remove先删除这个文件，再取消git的跟踪 move checking historydefault git log: return all the commit history -p: show the difference of each commit-2: just show the latest 2 commit--stat: show the simplified version amend有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 --amend 选项的提交命令来重新提交： cancel the file that have been staged cancel the file that have been commited TO NOTICE: Usually, the behaviors are dangerous. Take attention when using them. TO BE CONTINUED"},{"title":"CS 61B part4 Iterators, Exceptions","date":"2024-04-08T03:33:12.000Z","url":"/2024/04/08/61B/part4-Iterators/","tags":[["CS 61B","/tags/CS-61B/"],["Java","/tags/Java/"],["Iterators","/tags/Iterators/"],["Exceptions","/tags/Exceptions/"]],"categories":[["CS 61B","/categories/CS-61B/"]],"content":"prev:[[61B_Part_3_OOP]]next: [[Git-intro]]Hug61B chapter6 setsa collection of unique elements.you can only have one copy of each element. There is also no sense of order. Java set example use: Goal: make our own ArraySet, with the following methods: add(value): add the value to the set if not already present contains(value): check to see if ArraySet contains the key size(): return number of values our code: ExpectationsSmall error: when null was added to the set, the nullPointerException was raised. So, we would throw expectations when null was added. In Java, Exceptions are objects, and we throw exceptions using the following format: throw new ExceptionObject(parameter1, ...) the following code would be added: Why this one is better? we have control of our own code more useful error messages were got. Also, we can check if it is null to completely avoid the error. Iterationwe can do this with Java’s HashSet Why with our ArraySet, there is some questions? The nature of Enhanced For LoopsThe for loops above can be translated as the Iterator version: Iterator&lt;String&gt; seer = s.iterator();: build a new Iterator seer.hasNext(): whether the Iterator is still have items left seer.next(): return the next item and push the iterator by one item. Implementing IteratorsBased on the implementations above,the List interface have an iterator() method. also, the Iterator interface have next&#x2F;hasNext() methods. To implement it, we first write a new class called ArraySetIterator, nested inside ArraySet: Afterwards, we need to make ArraySet implement the Iterable interface. Iterable: the interface that makes a class able to be iterated on Iterator: the interface that defines the object with methods to actually do that iteration. Object methodsthe list of object methods we would explain the first two methods. toString()provides a string representation of an object System.out.println(dog); Actually run like this: Default: print the location of the object in memory(hexadecimal(十六进制的) string) Classes like Arraylist and java arrays have their own overridden versions of the toString() method. Therefore, if we want to print our class in a readable format, Override toString() is necessary. The overall solution of ArraySet is here. possible solution 1: Its efficiency is very low! when you use string concatenation in Java like so: returnString += keys[i] you are actually not just appending to returnString, you are creating an entirely new string. and it takes time. To solve this problem, Stringbuilder in Java helps to build the mutable string. equals()In Java, == checks if the two objects are actually the same object in the memory.If they are addresses, it means checking if the address is equal However, equals() method, in default, checks the same as ==. However, we can override the method todefine whatever we want! Rules for Equals in Java equals must be an equivalence relation reflexive: x.equals(x) is true symmetric: x.equals(y) if and only if y.equals(x) transitive: x.equals(y) and y.equals(z) implies x.equals(z) It must take an Object argument, in order to override the original .equals() method It must be consistent if x.equals(y), then as long as x and y remain unchanged: x must continue to equal y It is never true for null x.equals(null) must be false "},{"title":"part 1 search","date":"2024-04-07T09:30:10.000Z","url":"/2024/04/07/61B/part1_search/","tags":[["python","/tags/python/"],["CS","/tags/CS/"],["Basic","/tags/Basic/"],["AI","/tags/AI/"]],"categories":[["CS 188","/categories/CS-188/"]],"content":"searchA search problem consists of: ▪ A state space ▪ A successor function(with actions, costs) ▪ A start state and a goal test A solution is a sequence of actions (a plan) whichtransforms the start state to a goal state State Space Graphs vs. Search TreesState space graph: A mathematicalrepresentation of a search problem ▪ Nodes are (abstracted) world configurations ▪ Arcs represent successors (action results) ▪ The goal test is a set of goal nodes (maybe only one) ▪ A search tree: Possible futures ▪ A “what if” tree of plans and their outcomes ▪ The start state is the root node ▪ Children correspond to successors ▪ Nodes show states, but correspond to PLANS that achieve those states ▪ For most problems, we can never actually build the whole tree Search: (by the search tree) ▪ Expand out potential plans (tree nodes) ▪ Maintain a fringe of partial plans under consideration ▪ Try to expand as few tree nodes as possible tree search: DFS and BFS Depth-First Search (DFS) PropertiesWhat nodes DFS expand? ▪ Some left prefix of the tree. ▪ Could process the whole tree! ▪ If m is finite, takes time O(bm) How much space does the fringe take? ▪ Only has siblings on path to root, so O(bm) Is it complete? ▪ m could be infinite, so only if we preventcycles (more later) Is it optimal? ▪ No, it finds the “leftmost” solution,regardless of depth or cost Breadth-First Search (BFS)dig the breadth first Below: For map search HeuristicA heuristic is: ▪ A function that estimates how close a state is to a goal ▪ Designed for a particular search problem ▪ Examples: Manhattan distance, Euclidean distance forpathing Greedy Searchfind the one seems to be the closest Strategy: expand a node that you think is closest to a goal state Heuristic: estimate of distance to nearest goal foreach state A common case: Best-first takes you straight to the (wrong) goal Worst-case: like a badly-guided DFS "},{"title":"CS 61B Part 3  Inheritance, Implements, Iterators","date":"2024-04-06T01:38:03.000Z","url":"/2024/04/06/61B/61B_Part_3_OOP/","tags":[["CS 61B","/tags/CS-61B/"],["Java","/tags/Java/"],["OOP","/tags/OOP/"]],"categories":[["CS 61B","/categories/CS-61B/"]],"content":"prev:[[61B_Part_2_LinkList]]next:[[part4-Iterators]]Hug61B chapter4 Part 3 Inheritance, Implements, IteratorsoverloadSuppose we want to write a class WordUtilsthat includes functions we can run on lists of words, including a method that calculates the longest string in an SLList. make it suitable for AList? change the SLList&lt;String&gt; list into the AList&lt;String&gt; list! coexistence of the two functions are allowed in the function! (method overloading) interface In Java, in order to express this hierarchy, we need to do two things: Step 1: Define a type for the general list hypernym – we will choose the name List61B. Step 2: Specify that SLList and AList are hyponyms of that type. here is the 61B interface: then, we define this relationship in the class definition: overridingWhen implementing the required functions in the subclass, it’s useful (and actually required in 61B) to include the @Override tag right on top of the method signature. actually, the Override keyword is not needed. But it can be served as a checklist for us to debug. InheritanceInterface Inheritanceinterface can also inheritance. just have interface, no code! Implementation Inheritancewith default method, we can write default method in interfaces for SLList and AList, we write: However, the efficiency of the method in SLList and ‘AList’ differs. For an SLList, the get method needs to jump through the entirety of the list. during each call. It’s much better to just print while jumping through! for this, we need to override it: when adding: List61B&lt;String&gt; lst = new SLList&lt;String&gt;(); which print() to call? the SLList.print() one How do java know which print() to call? dynamic method selection (DMS)an object: compile-time type x run-time type y if y overrides the method, y’s method would be used instead. without @Override, the default method in the interface would be excuted! e.g.: Another way to understand DMS DMS as two-step process: compiling step &amp; running step Dynamic type of a is Dog. So use Dog’s praise(Animal) important: “is-a” relationships are better than “has-a” relationships. Extendsthe extends keywordclass is a hyponym of an interface –&gt; implements class is a hyponym of another class –&gt; extends featuresall methods from the superclass are contained change the method in the superclass: @Override you can also call the method in the superclass by super constructor: must come first with super Java requires that all constructors must start with a call to one of its superclass’s constructors. without super(x), you just get the default method! The reason: if run: TA Christine = new TA(); Then the TA would be human first, and then be TA! Object classevery class was extended from the Object class Encapsulation 封装Core: hiding information from the outside hiding information that others don’t need is another fundamental approach when managing a large system. a module: a set of methods that work together as a whole to perform a task or set of related tasks the private keyword: ensuring that the underlying complexity isn’t exposed to the outside world. How Inheritance Breaks Encapsulationexample 1: example 2: it is basically the same without inheritance. when overriding them: Given a VerboseDog vd, what would vd.barkMany(3) output, given the first implementation above? The second implementation? a: As a dog, I say: bark bark bark b: bark bark bark c: Something else Actually, for example 1, the answer is A for example 2, the answer is infinite loop. Type CheckingFor each line of code below, decide the following: Does that line cause a compilation error? Which method uses dynamic selection? The lines: sl.printLostItems(); a compile-time error: the compiler determines whether something is valid based on the static type of the object. Since sl is of static type SLList, and printLostItems is not defined in the SLList class, the code will not be allowed to run VengefulSLList&lt;Integer&gt; vsl2 = sl; also a compile-time error(similar reason) Like variables as seen above, expressions using the new keyword also have compile-time types. SLList&lt;Integer&gt; sl = new VengefulSLList&lt;Integer&gt;(); compile-time type of right hand side: VengefulSLList VengefulSLList&lt;Integer&gt; vsl = new SLList&lt;Integer&gt;(); compile-time type of right hand side: SLList Castingtell the compiler that the specific expression has a specific type Poodle largerPoodle = (Poodle) maxDog(frank, frankJr); // compiles! Right hand side has compile-time type Poodle after casting Caution: casting do not do its type-checking duties! One possible error: Higher-order functionsin python: In java: when calling: The new feature was added after Java8. To notice: Java is mainly an OOP language, so that its implementation of Functional Programming is much limited! Subtype PolymorphismJava: how objects can have many forms or types OOP: how an object can be regarded as an instance of its own class, an instance of its superclass, an instance of its superclass’s superclass, and so on. for python comparison: Explicit HoF Approach Subtype Polymorphism Approach An example: Max functiondebug the following program: the error was items[i] &gt; items[maxDex], in which the Object cannot be compared. In python or C++, &gt; operator can refer to different meanings when applied to different types of parameters. In Java, however, the operator cannot be done like this. Therefore, we can add a function like this: However, we have to rewrite the method for many other programs. Therefore, Instead, we turn to interface inheritance to help us out. We will define its behavior like so: Return -1 if this &lt; o. Return 0 if this equals o. Return 1 if this &gt; o. The implementation of it in class of Dog: then, we can generalize the function in previous: Benefits for it: No need for maximization code in every class(i.e. no Dog.maxDog(Dog[]) function required We have code that operates on multiple types (mostly) gracefully ComparablesThe interface OurComparable have some issues: Awkward casting to&#x2F;from Objects No existing classes implement OurComparable (e.g. String, etc.) No existing classes use OurComparable (e.g. no built-in max function that uses OurComparable) to fix them, we used the comparable interface that have been defined by Java. comparatoran interface that looks very similar inside: The rule for compare is just like compareTo. let’s give Dog class a NameComparator. The structure is: summarizeInterfaces in Java give us the ability to make callbacks. comparable: defines the natural ordering of a type (only one compareTo method can exist!) comparator: a third-party machine that compares two objects to each other. Multiple ways to compare –&gt; comparator"},{"title":"CS 61B Part 2 Linked List","date":"2024-04-05T16:21:02.000Z","url":"/2024/04/06/61B/61B_Part_2_LinkList/","tags":[["Java","/tags/Java/"],["CS","/tags/CS/"],["61B","/tags/61B/"]],"categories":[["CS 61B","/categories/CS-61B/"]],"content":"prev: [[61B_Part_1_Java]]next: [[61B_Part_3_OOP]] SLListWhile functional, “naked” linked lists like the one above are hard to use.Users of this class are probably going to need to know references very well, and be able to think recursively. Let’s make our users’ lives easier. 1: in large software engineering projects, the private keyword is the signal of the programs that needn’t to be understand by users. also, we can nest the classes: However, the recursion are really slow, as each time call size would recurse millions of times. So, we should create a varible called size directly. sentinal nodeto address the problem of empty list create the node for the first of the linked list sentinal.next is the first element of the SLList Lect6 Part 1: DLListAddLastthe formal addLast method is a little bit slow: as it walks through the whole list to find the best one. add the last varible: when deleting, the second last should be iterated to. add the double-link! so, a double-linked list(DLList) is in urgent need.(add, get, remove method also get faster!) Also, it is recommended that the last elements’ next return to the first, and the first elements’ last return to the last. Therefore, add .last and .prev method to fasten the linked list! we would build this in project 1A. SListhow to contain string into the Linked lists? we can put the parameter as a kind of varible! usage: Lecture 4 part 2: the arraysfinal objective: build a AList(using arrays instead of the recursive calls to make the Linked List) class VS arraysThe differences are: the array can be computed and used at the same time; but class CANNOT! (reflection API allow class to do so, but it is not recommended) Lect7 the ALists, resizingthe get(int i) method (Native ALList)get is really slow in the function! (compared with GetLast) 1. Naive Array Based Listusing arrays to build linked list Accessing the ith element of an array takes constant time on a modern computer. 2. removeLastIn removeLast, we should see change in our memory box! E2: Try to write removeLast. Before starting, decide which of size, items, and items[i] needs to change so that our invariants are preserved after the operation, i.e. so that future calls to our methods provide the user of the list class with the behavior they expect. 3. Naive Resizing ArraysHow to add the number of the arrays? In Java, the only way is to add the arrays that is large enough. the process is called resizing, meaning that the array didn’t change its size, but a new array with more members come. E4: Try to implement the addLast(int i) method to work with resizing arrays. ReflectionHowever, when comparing to our previous SLList, the ALList seemed to be very slow. Creating all those memory boxes and recopying their contents takes time! In SLList, each insert take the same time. In ALList, however, each insert take the time that linear increasing! We can fix our performance problems by growing the size of our array by a multiplicative amount, rather than an additive amount. for example: the additive one: the multiplicative one: which make our program faster. Why? because that the program is faster as the time of revising the size of the array is much smaller. to build a AList that the same speed as the DLList, we need to adapt the data structure below: lists in real java code another example: (more realistic) you can look up these words in Java official website!"},{"title":"CS 61B Part 1 Java","date":"2024-04-05T16:10:01.000Z","url":"/2024/04/06/61B/61B_Part_1_Java/","tags":[["Java","/tags/Java/"],["CS","/tags/CS/"],["61B","/tags/61B/"]],"categories":[["CS 61B","/categories/CS-61B/"]],"content":"prev: [[Basic_Java]]next: [[61B_Part_2_LinkList]] Compiling systemJava source code –&gt; (compiler) .class –&gt; (interpreter) running file why .class? no need to open sourcecode easier for computer to run (more to explain in 61C) Java compiling Class in Javain java, “self” in python is “this”. Static vs. Non-Static Methods Error! (There must be main classes) instances in the main function: another way to build the class: (very similar to __init__ method in Python) (then you can: Dog d = new Dog(21); instead of Dog d = new dog(); d.weightInPounds = 21;) arraysyou are also able to apply arrays in dog Class, like Dog[] dogs = new dog[2] Why static methods?some methods are never 变成实例. static methods usage: Dog.method() (never use this in non-static method!!!) Lecture 2 testing another method:(junit) in java, no a[1:]!!! to avoid using org.junit.Assert. and @org.junit.Test, you can import them like: lecture 3-5bits a’s weight is 5! However: b &#x3D; 5, a &#x3D; 1000! why different? In Walrus, a and b points to the same index of value However, int is different. In computer, data stored in memory. 8 java primary data types are 8 ways to interpret them.(byte, short, int, long, float, double, boolean, char) varible declearationdeclear a varible: 先申请一个box,然后 create a interal table that match each value into the location for this primary datatypes: varibles just match a box with sth. in it. golden rule of equals create the new file: check if dummy.txt exists: Writing the file in java is pretty ugly, so the class Utils.java was applied in this lab and Gitlet.For example, write a string to the file: Directoriesit also represents as File objects. to create: SerializableHow to save more complicated state in our program? such as the Model object in our 2048 program?we can use java.io.Serializable interface to translate an object to a series of bytes that can then be stored in the file. serialize: deserialize: "},{"title":"CS 61B Part 0.5 Java Debugging&Testing","date":"2024-04-05T16:00:10.000Z","url":"/2024/04/06/61B/java_debug/","tags":[["Java","/tags/Java/"],["debugging","/tags/debugging/"],["CS","/tags/CS/"],["61B","/tags/61B/"]],"categories":[["CS 61B","/categories/CS-61B/"]],"content":"prev: [[Basic_Java]]next: [[61B_Part_1_Java]] Breakpointsprevious debugging experience (Print statements): They require you to modify your code (to add print statements). They require you to explicitly state what you want to know (since you have to say precisely what you want to print). And they provide their results in a format that can be hard to read, since it’s just a big blob of text in the execution window.click the line, and now, we have breakpoint.click debugging , and the currently highlighted line is the line that is about to execute, not the line that has just executed. you should see that the program has paused at the line at which you set a breakpoint, and you should also see a list of all the variables at the bottom - step into: advancing the items into one step - step over: the same as step into, except the step that included in a function(step over the function) - step out: when step into go into the function, step out can step the function and return to the parent function - resume: run the code until hitting the code one more time conditional breakpointrightclick the line, and you can set up the conditional breakpoint. JUnit test All tests must be non-static.Run the test and you will see the error:"},{"title":"CS 61B Part 0 Basic Java","date":"2024-04-05T16:00:00.000Z","url":"/2024/04/06/61B/Basic_Java/","tags":[["CS 61B","/tags/CS-61B/"],["Java","/tags/Java/"]],"categories":[["CS 61B","/categories/CS-61B/"]],"content":"next:[[61B_Part_1_Java]] Java program skeletonno need to worry about the retract(缩进) (like in python). Just like C++! conditionsif other version: else &amp; else if loopswhile for another version of the for loop in java: of course, you can use break; or continue; in Java user-defined functionsuse public static before making a user-defined functions All parameters, and functions themselves master have a type. All functions must be in a class, so all functions in Java are methods. data typesImportant ones:In Java, varibles are first varified before the code runs!!! If there are type issues, Java would simply not run. (You don’t want your TikTok broken down when having a video) normal onesint, double, string Arrays (list in Python) simpler one: "},{"title":"CS 61A calculators","date":"2024-04-04T16:00:20.000Z","url":"/2024/04/05/CS61A/CS61A_calculators/","tags":[["CS 61A","/tags/CS-61A/"]],"categories":[["CS 61A","/categories/CS-61A/"]],"content":"parsingtext &#x3D;&gt; lextical analysis &#x3D;&gt; tokens &#x3D;&gt; syntactic analysis &#x3D;&gt; expression reducereduce(, , …) pass in the parameters(maybe in the form of a list) and apply them to the function"},{"title":"CS 61A errors","date":"2024-04-04T16:00:19.000Z","url":"/2024/04/05/CS61A/CS61A_errors/","tags":[["CS 61A","/tags/CS-61A/"]],"categories":[["CS 61A","/categories/CS-61A/"]],"content":"errorsassertassert , if body &#x3D; False, end the program and print “reaction” e.g.:assert False, “Error” raisetrigger errorsan example: try statementtry: …except as : …example: "},{"title":"CS 61A Scheme","date":"2024-04-04T16:00:18.000Z","url":"/2024/04/05/CS61A/CS61A_Scheme/","tags":[["CS 61A","/tags/CS-61A/"],["Scheme","/tags/Scheme/"]],"categories":[["CS 61A","/categories/CS-61A/"]],"content":"Schemesymbolsbooleanst truef falsestrings‘hello world! numbersno need to say calculations(+ 1 2) 3 (the same: +-*&#x2F;&lt;&gt;&#x3D;) (modulo 35 4) 3 logic (if python: cond and &amp; or and (and x1 x2 …) or (or x1 x2 …) symbolsbooleanst truef falsestrings‘hello world! numbersno need to say calculations(+ 1 2) 3 (the same: +-*&#x2F;&lt;&gt;&#x3D;) (modulo 35 4) 3 logic (if definationparameter: (define ) (define x 2) functions(precedure in Scheme): (define ( ) ) (define (add_four x) x+4) (lambda () ) (temporate binding) let() expression (define c (let (a 3) (b (+ 2 2)))(sqrt (+ (a a) ( b b)))) link lists • cons: Two-argument procedure that creates a linked list • car: Procedure that returns the first element of a list • cdr: Procedure that returns the rest of a list • nil: The empty list list: join the lists&#x2F;elements together quotation marksquotations (‘a)cons(1, a) error! cons(1, ‘a) (1, a) quasiquotations (&#96;a)‘(a ,(+ b 1)) &#x3D;&gt; (a (unquote (+ b 1)) &#96;(a ,(+ b 1)) &#x3D;&gt; (a 5) for generating scheme programs unquote (,a)programs are languagesscheme sentences are listsscm&gt; (list ‘quotient 10 2) (quotient 10 2) scm&gt; (eval (list ‘quotient 10 2)) 5 for example:to generate while statement for scheme python: scheme: "},{"title":"CS 61A lect11","date":"2024-04-04T16:00:11.000Z","url":"/2024/04/05/CS61A/CS61A%20lect11/","tags":[["CS 61A","/tags/CS-61A/"]],"categories":[["CS 61A","/categories/CS-61A/"]],"content":"CS61A lect11 data abstraction•rational(n, d) returns a rational number x•numer(x) returns the numerator of x•denom(x) returns the denominator of x(These functions implement an abstract representation for rational numbers)for whole data: for a part of data:(do not combine these with above) 实际操作：尽量不要用直接赋值， 要用constructor和dominator！！！another approach: use dictionary-like functions dictionary(taught in high school) different: dic.keys()—list of all the keys dic.values()—list of all the values dic.items()—list of all the items dict(items)—from list to dict Dictionaries are unordered collections of key-value pairsDictionary keys do have two restrictions:•A key of a dictionary cannot be a list or a dictionary (or any mutable type)•Two keys cannot be equal; There can be at most one value for a given keyThis first restriction is tied to Python’s underlying implementation of dictionariesThe second restriction is part of the dictionary abstractionIf you want to associate multiple values with a key, store them all in a sequence value"},{"title":"CS 61A lect9 tree recusion","date":"2024-04-04T16:00:09.000Z","url":"/2024/04/05/CS61A/CS61A%20lect9/","tags":[["CS 61A","/tags/CS-61A/"]],"categories":[["CS 61A","/categories/CS-61A/"]],"content":"CS61A lect9 tree recusion• Each cascade frame is from a different call to cascade.• Until the Return value appears, that call has not completed.• Any statement can appear before or after the recursive call.Write a function that prints an inverse cascade:1121231234123121 tree recursiveThe computational process of fib evolves into a tree structure汉诺塔： "},{"title":"CS 61A lect8 recursion","date":"2024-04-04T16:00:08.000Z","url":"/2024/04/05/CS61A/CS61A%20lect8/","tags":[["CS 61A","/tags/CS-61A/"]],"categories":[["CS 61A","/categories/CS-61A/"]],"content":"CS61A lect8: recusionThe Anatomy of a Recursive FunctionThe def statement header is similar to other functions• Conditional statements check for base cases• Base cases are evaluated without recursive calls• Recursive cases are evaluated with recursive calls Iteration is a special case of recursion."},{"title":"CS 61A lect6 code standards","date":"2024-04-04T16:00:06.000Z","url":"/2024/04/05/CS61A/CS61A%20lect6/","tags":[["CS 61A","/tags/CS-61A/"]],"categories":[["CS 61A","/categories/CS-61A/"]],"content":"CS61A lect6 code standardsChoosing NamesNames typically don’t matter for correctnessbut they matter a lot for compositionNames should convey the meaning or purpose of the values to which they are bound.The type of value bound to the name is best documented in a function’s docstring.Function names typically convey their effect (print), their behavior (triple), or the value returned (abs)Which Values Deserve a NameRepeated compound expressionsMeaningful parts of complex expressionsMore Naming Tips• Names can be long if they helpdocument your code:average_age = average(age, students) is preferable to • Names can be short if they representgeneric quantities: counts,arbitrary functions, arguments tomathematical operations, etc.n, k, i - Usually integersx, y, z - Usually real numbersf, g, h - Usually functions"},{"title":"CS 61A lect5","date":"2024-04-04T16:00:05.000Z","url":"/2024/04/05/CS61A/CS61A%20lect5/","tags":[["CS 61A","/tags/CS-61A/"]],"categories":[["CS 61A","/categories/CS-61A/"]],"content":"CS61A lect5Environments for Higher-Order Functions Applying a user-defined function:• Create a new frame• Bind formal parameters (f &amp; x) to arguments• Execute the body: return f(f(x))Nested Def Statements Every user-defined function has a parent frame (often global)• The parent of a function is the frame in which it was defined• Every local frame has a parent frame (often global)• The parent of a frame is the parent of the function calledHow to Draw an Environment DiagramWhen a function is defined:Create a function value: func () [parent&#x3D;]Its parent is the current frame. Bind to the function value in the current frameWhen a function is called: Add a local frame, titled with the of the function being called.2. Copy the parent of the function to the local frame: [parent&#x3D;] Bind the to the arguments in the local frame. Execute the body of the function in the environment that starts with the local frame.Local Names are not Visible to Other (Non-Nested) Functions Self-Reference:Returning a Function Using Its Own Name Function CurryingCurry: Transform a multi-argument function into a single-argument, higher-order function "},{"title":"CS 61A lect4","date":"2024-04-04T16:00:04.000Z","url":"/2024/04/05/CS61A/CS61A_lect4/","tags":[["CS 61A","/tags/CS-61A/"]],"categories":[["CS 61A","/categories/CS-61A/"]],"content":"CS61A lect4 Describing FunctionsA function’s domain is the set of all inputs it might possibly take as arguments.A function’s range is the set of output values it might possibly return.A pure function’s behavior is the relationship it creates between input and outputGive each function exactly one job, but make it apply to many related situations!Don’t repeat yourself (DRY): Implement a process just once, but execute it many timesGeneralizing Over Computational ProcessesSummation Example: Functions as Return Values Functions defined within other function bodies are bound to names in a local frame make_adder(3)(4)oprater operandLambda Expressionssquare = lambda x: x * xan expression: evaluates to a functionunimportant in Python but important in other languagesLambda Expressions Versus Def StatementsOnly the def statement gives the function an intrinsic name, which shows up in environment diagrams but doesn’t affect execution (unless the function is printed)returnreturn statements:A return statement completes the evaluation of a call expression and provides its value:f(x) for user-defined function f: switch to a new environment; execute f’s bodyOnly one return statement is ever executed while executing the body of a functionreturn None—-End the function directlycontroldifference: andif_(________, ________, ________)Execution Rule for Conditional Statements:Each clause is considered in order. Evaluate the header’s expression (if present). If it is a true value (or an else header), execute the suite &amp; skip the remaining clauses.Evaluation Rule for Call Expressions: Evaluate the operator and then the operand subexpressions Apply the function that is the value of the operator to the arguments that are the values of the operands Logical OperatorsTo evaluate the expression and : Evaluate the subexpression . If the result is a false value v, then the expression evaluates to v. Otherwise, the expression evaluates to the value of the subexpression .To evaluate the expression or : Evaluate the subexpression . If the result is a true value v, then the expression evaluates to v. Otherwise, the expression evaluates to the value of the subexpression . Conditional ExpressionsA conditional expression has the form if "},{"title":"CS 61A lect3","date":"2024-04-04T16:00:03.000Z","url":"/2024/04/05/CS61A/CS61A_lect3/","tags":[["CS 61A","/tags/CS-61A/"]],"categories":[["CS 61A","/categories/CS-61A/"]],"content":"CS61A lect3None Indicates that Nothing is Returned:The special value None represents nothing in PythonA function that does not explicitly return a value will return NoneCareful: None is not displayed by the interpreter as the value of an expressionexample:print(print(1), print(2))12None None Miscellaneous Python Featuresinterept：python3 -i xx.pymultiple return valuesdoctests:write inputs in the 注释！for example:&quot;&quot;&quot;&gt;&gt;&gt;q, r=divide_exact(5, 3)&gt;&gt;&gt;q201&gt;&gt;&gt;r3&quot;&quot;&quot;python3 -m doctest -v xx.pyCompound StatementsExecution Rule for a sequence of statements:• Execute the first statement• Unless directed otherwise, execute the restConditional StatementsExecution Rule for Conditional Statements:Each clause is considered in order. Evaluate the header’s expression. If it is a true value, execute the suite &amp; skip the remaining clauses. Syntax Tips: Always starts with “if” clause. Zero or more “elif” clauses. Zero or one “else” clause, always at the end.Boolean ContextsFalse values in Python: False, 0, ‘’, NoneTrue values in Python: OthersWhile StatementsExecution Rule for While Statements: Evaluate the header’s expression. If it is a true value, execute the (whole) suite, then return to step 1. "},{"title":"CS 61A lect2","date":"2024-04-04T16:00:02.000Z","url":"/2024/04/05/CS61A/CS61A_lect2/","tags":[["CS 61A","/tags/CS-61A/"]],"categories":[["CS 61A","/categories/CS-61A/"]],"content":"CS61A lect2Anatomy of a Call Expression：operator, operandadd ( 2 , 3 ) Operator Operand Operand Operators and operands are also expressions Evaluation procedure for call expressions: Evaluate the operator and then the operand subexpressions Apply the function that is the value of the operator to the arguments that are the values of the operands Execution rule for assignment statements: Evaluate all expressions to the right of &#x3D; from left to right. Bind all names to the left of &#x3D; to those resulting values in the current frame. Execution procedure for def statements: Create a function with signature &lt;name&gt;(&lt;formal parameters&gt;) Set the body of that function to be everything indented after the first line Bind &lt;name&gt; to that function in the current frame Procedure for calling&#x2F;applying user-defined functions (version 1): Add a local frame, forming a new environment Bind the function’s formal parameters to its arguments in that frame Execute the body of the function in that new environment Most important two things I’ll say all day: An environment is a sequence of frames. A name evaluates to the value bound to that name in the earliest frame of the current environment in which that name is found. Exercise: What is the value of the final expression in this sequence? f = min f = max g, h = min, max max = g max(f(2, g(h(1, 5), 3)), 4)"}]